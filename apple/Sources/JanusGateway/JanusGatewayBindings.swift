// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(JanusGatewayFFI)
import JanusGatewayFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_janus_gateway_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_janus_gateway_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureJanusGatewayInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol AudioBridgeHandleProtocol: AnyObject, Sendable {
    
    func completeTrickle(timeout: TimeInterval) async throws 
    
    func configure(params: AudioBridgeConfigureParams, jsep: Jsep?, timeout: TimeInterval) async throws  -> String
    
    func createRoom(params: AudioBridgeCreateParams, timeout: TimeInterval) async throws  -> AudioBridgeRoomCreatedRsp
    
    func detach() async throws 
    
    func exist(roomId: JanusId, timeout: TimeInterval) async throws  -> Bool
    
    func fireAndForget(data: Data) async throws 
    
    func fireAndForgetWithJsep(data: Data, jsep: Jsep) async throws 
    
    func hangup() async throws 
    
    func joinRoom(params: AudioBridgeJoinParams, jsep: Jsep?, timeout: TimeInterval) async throws  -> String
    
    func listParticipants(roomId: JanusId, timeout: TimeInterval) async throws  -> AudioBridgeListParticipantsRsp
    
    func mute(params: AudioBridgeMuteParams) async throws  -> String
    
    func sendWaitonAck(data: Data, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonAckWithJsep(data: Data, jsep: Jsep, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonResult(data: Data, timeout: TimeInterval) async throws  -> Data
    
    func startEventLoop(cb: AudioBridgeHandleCallback) async 
    
    func trickleCandidates(candidates: [Candidate], timeout: TimeInterval) async throws 
    
    func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval) async throws 
    
    func unmute(params: AudioBridgeMuteParams) async throws  -> String
    
}
open class AudioBridgeHandle: AudioBridgeHandleProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_audiobridgehandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_audiobridgehandle(pointer, $0) }
    }

    

    
open func completeTrickle(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_complete_trickle(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func configure(params: AudioBridgeConfigureParams, jsep: Jsep?, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_configure(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAudioBridgeConfigureParams_lower(params),FfiConverterOptionTypeJsep.lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func createRoom(params: AudioBridgeCreateParams, timeout: TimeInterval)async throws  -> AudioBridgeRoomCreatedRsp  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_create_room(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAudioBridgeCreateParams_lower(params),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAudioBridgeRoomCreatedRsp_lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func detach()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_detach(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func exist(roomId: JanusId, timeout: TimeInterval)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_exist(
                    self.uniffiClonePointer(),
                    FfiConverterTypeJanusId_lower(roomId),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_i8,
            completeFunc: ffi_janus_gateway_rust_future_complete_i8,
            freeFunc: ffi_janus_gateway_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func fireAndForget(data: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_fire_and_forget(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func fireAndForgetWithJsep(data: Data, jsep: Jsep)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_fire_and_forget_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func hangup()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_hangup(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func joinRoom(params: AudioBridgeJoinParams, jsep: Jsep?, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_join_room(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAudioBridgeJoinParams_lower(params),FfiConverterOptionTypeJsep.lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func listParticipants(roomId: JanusId, timeout: TimeInterval)async throws  -> AudioBridgeListParticipantsRsp  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_list_participants(
                    self.uniffiClonePointer(),
                    FfiConverterTypeJanusId_lower(roomId),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAudioBridgeListParticipantsRsp_lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func mute(params: AudioBridgeMuteParams)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_mute(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAudioBridgeMuteParams_lower(params)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonAck(data: Data, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_send_waiton_ack(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonAckWithJsep(data: Data, jsep: Jsep, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_send_waiton_ack_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonResult(data: Data, timeout: TimeInterval)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_send_waiton_result(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func startEventLoop(cb: AudioBridgeHandleCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_start_event_loop(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceAudioBridgeHandleCallback_lower(cb)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func trickleCandidates(candidates: [Candidate], timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_trickle_candidates(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeCandidate.lower(candidates),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_trickle_single_candidate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCandidate_lower(candidate),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func unmute(params: AudioBridgeMuteParams)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_unmute(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAudioBridgeMuteParams_lower(params)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AudioBridgeHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AudioBridgeHandle {
        return AudioBridgeHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AudioBridgeHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AudioBridgeHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> AudioBridgeHandle {
    return try FfiConverterTypeAudioBridgeHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeHandle_lower(_ value: AudioBridgeHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAudioBridgeHandle.lower(value)
}






public protocol ConnectionProtocol: AnyObject, Sendable {
    
    func createSession(keepAliveIntervalInSecs: UInt32, timeout: TimeInterval) async throws  -> Session
    
    func serverInfo(timeout: TimeInterval) async throws  -> ServerInfoRsp
    
}
open class Connection: ConnectionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_connection(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_connection(pointer, $0) }
    }

    

    
open func createSession(keepAliveIntervalInSecs: UInt32, timeout: TimeInterval)async throws  -> Session  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_connection_create_session(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(keepAliveIntervalInSecs),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeSession_lift,
            errorHandler: FfiConverterTypeJanusGatewaySessionError_lift
        )
}
    
open func serverInfo(timeout: TimeInterval)async throws  -> ServerInfoRsp  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_connection_server_info(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeServerInfoRsp_lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnection: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Connection

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Connection {
        return Connection(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Connection) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Connection {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Connection, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnection_lift(_ pointer: UnsafeMutableRawPointer) throws -> Connection {
    return try FfiConverterTypeConnection.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnection_lower(_ value: Connection) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConnection.lower(value)
}






public protocol EchotestHandleProtocol: AnyObject, Sendable {
    
    func completeTrickle(timeout: TimeInterval) async throws 
    
    func detach() async throws 
    
    func fireAndForget(data: Data) async throws 
    
    func fireAndForgetWithJsep(data: Data, jsep: Jsep) async throws 
    
    func hangup() async throws 
    
    func sendWaitonAck(data: Data, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonAckWithJsep(data: Data, jsep: Jsep, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonResult(data: Data, timeout: TimeInterval) async throws  -> Data
    
    func start(params: EchoTestStartParams) async throws 
    
    func startEventLoop(cb: EchotestHandleCallback) async 
    
    func startWithJsep(params: EchoTestStartParams, jsep: Jsep, timeout: TimeInterval) async throws 
    
    func trickleCandidates(candidates: [Candidate], timeout: TimeInterval) async throws 
    
    func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval) async throws 
    
}
open class EchotestHandle: EchotestHandleProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_echotesthandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_echotesthandle(pointer, $0) }
    }

    

    
open func completeTrickle(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_complete_trickle(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func detach()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_detach(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func fireAndForget(data: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_fire_and_forget(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func fireAndForgetWithJsep(data: Data, jsep: Jsep)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_fire_and_forget_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func hangup()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_hangup(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonAck(data: Data, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_send_waiton_ack(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonAckWithJsep(data: Data, jsep: Jsep, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_send_waiton_ack_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonResult(data: Data, timeout: TimeInterval)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_send_waiton_result(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func start(params: EchoTestStartParams)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_start(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEchoTestStartParams_lower(params)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func startEventLoop(cb: EchotestHandleCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_start_event_loop(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceEchotestHandleCallback_lower(cb)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func startWithJsep(params: EchoTestStartParams, jsep: Jsep, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_start_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEchoTestStartParams_lower(params),FfiConverterTypeJsep_lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func trickleCandidates(candidates: [Candidate], timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_trickle_candidates(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeCandidate.lower(candidates),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_trickle_single_candidate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCandidate_lower(candidate),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEchotestHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EchotestHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EchotestHandle {
        return EchotestHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EchotestHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EchotestHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EchotestHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEchotestHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> EchotestHandle {
    return try FfiConverterTypeEchotestHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEchotestHandle_lower(_ value: EchotestHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEchotestHandle.lower(value)
}






public protocol HandleProtocol: AnyObject, Sendable {
    
    func completeTrickle(timeout: TimeInterval) async throws 
    
    func detach() async throws 
    
    func fireAndForget(data: Data) async throws 
    
    func fireAndForgetWithJsep(data: Data, jsep: Jsep) async throws 
    
    func hangup() async throws 
    
    func sendWaitonAck(data: Data, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonAckWithJsep(data: Data, jsep: Jsep, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonResult(data: Data, timeout: TimeInterval) async throws  -> Data
    
    func startEventLoop(cb: HandleCallback) async 
    
    func trickleCandidates(candidates: [Candidate], timeout: TimeInterval) async throws 
    
    func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval) async throws 
    
}
open class Handle: HandleProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_handle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_handle(pointer, $0) }
    }

    

    
open func completeTrickle(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_complete_trickle(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func detach()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_detach(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func fireAndForget(data: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_fire_and_forget(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func fireAndForgetWithJsep(data: Data, jsep: Jsep)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_fire_and_forget_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func hangup()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_hangup(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonAck(data: Data, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_send_waiton_ack(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonAckWithJsep(data: Data, jsep: Jsep, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_send_waiton_ack_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonResult(data: Data, timeout: TimeInterval)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_send_waiton_result(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func startEventLoop(cb: HandleCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_start_event_loop(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceHandleCallback_lower(cb)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func trickleCandidates(candidates: [Candidate], timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_trickle_candidates(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeCandidate.lower(candidates),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_trickle_single_candidate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCandidate_lower(candidate),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Handle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Handle {
        return Handle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Handle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Handle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Handle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> Handle {
    return try FfiConverterTypeHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHandle_lower(_ value: Handle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHandle.lower(value)
}






public protocol LegacyVideoRoomHandleProtocol: AnyObject, Sendable {
    
    func completeTrickle(timeout: TimeInterval) async throws 
    
    func createRoom(params: LegacyVideoRoomCreateParams, timeout: TimeInterval) async throws  -> LegacyVideoRoomCreatedRsp
    
    func detach() async throws 
    
    func exist(room: JanusId, timeout: TimeInterval) async throws  -> Bool
    
    func fireAndForget(data: Data) async throws 
    
    func fireAndForgetWithJsep(data: Data, jsep: Jsep) async throws 
    
    func hangup() async throws 
    
    func kick(params: LegacyVideoRoomKickParams, timeout: TimeInterval) async throws 
    
    func publisherConfigure(params: LegacyVideoRoomPublisherConfigureParams, timeout: TimeInterval) async throws  -> String
    
    func publisherJoin(params: LegacyVideoRoomPublisherJoinParams, jsep: Jsep?, timeout: TimeInterval) async throws  -> String
    
    func publisherJoinAndConfigure(params: LegacyVideoRoomPublisherJoinAndConfigureParams, jsep: Jsep?, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonAck(data: Data, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonAckWithJsep(data: Data, jsep: Jsep, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonResult(data: Data, timeout: TimeInterval) async throws  -> Data
    
    func start(jsep: Jsep, timeout: TimeInterval) async throws  -> String
    
    func startEventLoop(cb: LegacyVideoRoomHandleCallback) async 
    
    func subscriberConfigure(params: LegacyVideoRoomSubscriberConfigureParams, timeout: TimeInterval) async throws  -> String
    
    func subscriberJoin(params: LegacyVideoRoomSubscriberJoinParams, timeout: TimeInterval) async throws  -> String
    
    func trickleCandidates(candidates: [Candidate], timeout: TimeInterval) async throws 
    
    func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval) async throws 
    
}
open class LegacyVideoRoomHandle: LegacyVideoRoomHandleProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_legacyvideoroomhandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_legacyvideoroomhandle(pointer, $0) }
    }

    

    
open func completeTrickle(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_complete_trickle(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func createRoom(params: LegacyVideoRoomCreateParams, timeout: TimeInterval)async throws  -> LegacyVideoRoomCreatedRsp  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_create_room(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLegacyVideoRoomCreateParams_lower(params),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLegacyVideoRoomCreatedRsp_lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func detach()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_detach(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func exist(room: JanusId, timeout: TimeInterval)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_exist(
                    self.uniffiClonePointer(),
                    FfiConverterTypeJanusId_lower(room),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_i8,
            completeFunc: ffi_janus_gateway_rust_future_complete_i8,
            freeFunc: ffi_janus_gateway_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func fireAndForget(data: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_fire_and_forget(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func fireAndForgetWithJsep(data: Data, jsep: Jsep)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_fire_and_forget_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func hangup()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_hangup(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func kick(params: LegacyVideoRoomKickParams, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_kick(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLegacyVideoRoomKickParams_lower(params),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func publisherConfigure(params: LegacyVideoRoomPublisherConfigureParams, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_publisher_configure(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLegacyVideoRoomPublisherConfigureParams_lower(params),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func publisherJoin(params: LegacyVideoRoomPublisherJoinParams, jsep: Jsep?, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_publisher_join(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLegacyVideoRoomPublisherJoinParams_lower(params),FfiConverterOptionTypeJsep.lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func publisherJoinAndConfigure(params: LegacyVideoRoomPublisherJoinAndConfigureParams, jsep: Jsep?, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_publisher_join_and_configure(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLegacyVideoRoomPublisherJoinAndConfigureParams_lower(params),FfiConverterOptionTypeJsep.lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonAck(data: Data, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_send_waiton_ack(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonAckWithJsep(data: Data, jsep: Jsep, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_send_waiton_ack_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonResult(data: Data, timeout: TimeInterval)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_send_waiton_result(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func start(jsep: Jsep, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_start(
                    self.uniffiClonePointer(),
                    FfiConverterTypeJsep_lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func startEventLoop(cb: LegacyVideoRoomHandleCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_start_event_loop(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback_lower(cb)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func subscriberConfigure(params: LegacyVideoRoomSubscriberConfigureParams, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_subscriber_configure(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLegacyVideoRoomSubscriberConfigureParams_lower(params),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func subscriberJoin(params: LegacyVideoRoomSubscriberJoinParams, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_subscriber_join(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLegacyVideoRoomSubscriberJoinParams_lower(params),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func trickleCandidates(candidates: [Candidate], timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_trickle_candidates(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeCandidate.lower(candidates),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_legacyvideoroomhandle_trickle_single_candidate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCandidate_lower(candidate),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LegacyVideoRoomHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LegacyVideoRoomHandle {
        return LegacyVideoRoomHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LegacyVideoRoomHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LegacyVideoRoomHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> LegacyVideoRoomHandle {
    return try FfiConverterTypeLegacyVideoRoomHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomHandle_lower(_ value: LegacyVideoRoomHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLegacyVideoRoomHandle.lower(value)
}






public protocol SessionProtocol: AnyObject, Sendable {
    
    func attach(pluginId: String, timeout: TimeInterval) async throws  -> Handle
    
    func attachAudioBridge(timeout: TimeInterval) async throws  -> AudioBridgeHandle
    
    func attachEchoTest(timeout: TimeInterval) async throws  -> EchotestHandle
    
    func attachLegacyVideoRoom(timeout: TimeInterval) async throws  -> LegacyVideoRoomHandle
    
    func attachVideoRoom(timeout: TimeInterval) async throws  -> VideoRoomHandle
    
    func destory(timeout: TimeInterval) async throws 
    
}
open class Session: SessionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_session(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_session(pointer, $0) }
    }

    

    
open func attach(pluginId: String, timeout: TimeInterval)async throws  -> Handle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_session_attach(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(pluginId),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeHandle_lift,
            errorHandler: FfiConverterTypeJanusGatewayHandleError_lift
        )
}
    
open func attachAudioBridge(timeout: TimeInterval)async throws  -> AudioBridgeHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_session_attach_audio_bridge(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeAudioBridgeHandle_lift,
            errorHandler: FfiConverterTypeJanusGatewayHandleError_lift
        )
}
    
open func attachEchoTest(timeout: TimeInterval)async throws  -> EchotestHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_session_attach_echo_test(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEchotestHandle_lift,
            errorHandler: FfiConverterTypeJanusGatewayHandleError_lift
        )
}
    
open func attachLegacyVideoRoom(timeout: TimeInterval)async throws  -> LegacyVideoRoomHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_session_attach_legacy_video_room(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeLegacyVideoRoomHandle_lift,
            errorHandler: FfiConverterTypeJanusGatewayHandleError_lift
        )
}
    
open func attachVideoRoom(timeout: TimeInterval)async throws  -> VideoRoomHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_session_attach_video_room(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeVideoRoomHandle_lift,
            errorHandler: FfiConverterTypeJanusGatewayHandleError_lift
        )
}
    
open func destory(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_session_destory(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSession: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Session

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Session {
        return Session(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Session) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> Session {
    return try FfiConverterTypeSession.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lower(_ value: Session) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSession.lower(value)
}






public protocol VideoRoomHandleProtocol: AnyObject, Sendable {
    
    func completeTrickle(timeout: TimeInterval) async throws 
    
    func createRoom(params: VideoRoomCreateParams, timeout: TimeInterval) async throws  -> VideoRoomCreatedRsp
    
    func detach() async throws 
    
    func exist(roomId: JanusId, timeout: TimeInterval) async throws  -> Bool
    
    func fireAndForget(data: Data) async throws 
    
    func fireAndForgetWithJsep(data: Data, jsep: Jsep) async throws 
    
    func hangup() async throws 
    
    func publisherJoinAndConfigure(params: VideoRoomPublisherJoinAndConfigureParams, jsep: Jsep?, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonAck(data: Data, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonAckWithJsep(data: Data, jsep: Jsep, timeout: TimeInterval) async throws  -> String
    
    func sendWaitonResult(data: Data, timeout: TimeInterval) async throws  -> Data
    
    func startEventLoop(cb: VideoRoomHandleCallback) async 
    
    func trickleCandidates(candidates: [Candidate], timeout: TimeInterval) async throws 
    
    func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval) async throws 
    
}
open class VideoRoomHandle: VideoRoomHandleProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_videoroomhandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_videoroomhandle(pointer, $0) }
    }

    

    
open func completeTrickle(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_complete_trickle(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func createRoom(params: VideoRoomCreateParams, timeout: TimeInterval)async throws  -> VideoRoomCreatedRsp  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_create_room(
                    self.uniffiClonePointer(),
                    FfiConverterTypeVideoRoomCreateParams_lower(params),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeVideoRoomCreatedRsp_lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func detach()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_detach(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func exist(roomId: JanusId, timeout: TimeInterval)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_exist(
                    self.uniffiClonePointer(),
                    FfiConverterTypeJanusId_lower(roomId),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_i8,
            completeFunc: ffi_janus_gateway_rust_future_complete_i8,
            freeFunc: ffi_janus_gateway_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func fireAndForget(data: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_fire_and_forget(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func fireAndForgetWithJsep(data: Data, jsep: Jsep)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_fire_and_forget_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func hangup()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_hangup(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func publisherJoinAndConfigure(params: VideoRoomPublisherJoinAndConfigureParams, jsep: Jsep?, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_publisher_join_and_configure(
                    self.uniffiClonePointer(),
                    FfiConverterTypeVideoRoomPublisherJoinAndConfigureParams_lower(params),FfiConverterOptionTypeJsep.lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonAck(data: Data, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_send_waiton_ack(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonAckWithJsep(data: Data, jsep: Jsep, timeout: TimeInterval)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_send_waiton_ack_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func sendWaitonResult(data: Data, timeout: TimeInterval)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_send_waiton_result(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func startEventLoop(cb: VideoRoomHandleCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_start_event_loop(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceVideoRoomHandleCallback_lower(cb)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func trickleCandidates(candidates: [Candidate], timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_trickle_candidates(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeCandidate.lower(candidates),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    
open func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_videoroomhandle_trickle_single_candidate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCandidate_lower(candidate),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = VideoRoomHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> VideoRoomHandle {
        return VideoRoomHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: VideoRoomHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: VideoRoomHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> VideoRoomHandle {
    return try FfiConverterTypeVideoRoomHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomHandle_lower(_ value: VideoRoomHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVideoRoomHandle.lower(value)
}




public struct AudioBridgeConfigureParams {
    public let muted: Bool?
    public let display: String?
    public let bitrate: UInt64?
    public let quality: UInt8?
    public let expectedLoss: UInt8?
    public let volume: UInt64?
    public let spatialPosition: UInt8?
    public let denoise: Bool?
    public let record: Bool?
    public let filename: String?
    public let group: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(muted: Bool? = nil, display: String? = nil, bitrate: UInt64? = nil, quality: UInt8? = nil, expectedLoss: UInt8? = nil, volume: UInt64? = nil, spatialPosition: UInt8? = nil, denoise: Bool? = nil, record: Bool? = nil, filename: String? = nil, group: String? = nil) {
        self.muted = muted
        self.display = display
        self.bitrate = bitrate
        self.quality = quality
        self.expectedLoss = expectedLoss
        self.volume = volume
        self.spatialPosition = spatialPosition
        self.denoise = denoise
        self.record = record
        self.filename = filename
        self.group = group
    }
}

#if compiler(>=6)
extension AudioBridgeConfigureParams: Sendable {}
#endif


extension AudioBridgeConfigureParams: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeConfigureParams, rhs: AudioBridgeConfigureParams) -> Bool {
        if lhs.muted != rhs.muted {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.bitrate != rhs.bitrate {
            return false
        }
        if lhs.quality != rhs.quality {
            return false
        }
        if lhs.expectedLoss != rhs.expectedLoss {
            return false
        }
        if lhs.volume != rhs.volume {
            return false
        }
        if lhs.spatialPosition != rhs.spatialPosition {
            return false
        }
        if lhs.denoise != rhs.denoise {
            return false
        }
        if lhs.record != rhs.record {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        if lhs.group != rhs.group {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(muted)
        hasher.combine(display)
        hasher.combine(bitrate)
        hasher.combine(quality)
        hasher.combine(expectedLoss)
        hasher.combine(volume)
        hasher.combine(spatialPosition)
        hasher.combine(denoise)
        hasher.combine(record)
        hasher.combine(filename)
        hasher.combine(group)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeConfigureParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeConfigureParams {
        return
            try AudioBridgeConfigureParams(
                muted: FfiConverterOptionBool.read(from: &buf), 
                display: FfiConverterOptionString.read(from: &buf), 
                bitrate: FfiConverterOptionUInt64.read(from: &buf), 
                quality: FfiConverterOptionUInt8.read(from: &buf), 
                expectedLoss: FfiConverterOptionUInt8.read(from: &buf), 
                volume: FfiConverterOptionUInt64.read(from: &buf), 
                spatialPosition: FfiConverterOptionUInt8.read(from: &buf), 
                denoise: FfiConverterOptionBool.read(from: &buf), 
                record: FfiConverterOptionBool.read(from: &buf), 
                filename: FfiConverterOptionString.read(from: &buf), 
                group: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeConfigureParams, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.muted, into: &buf)
        FfiConverterOptionString.write(value.display, into: &buf)
        FfiConverterOptionUInt64.write(value.bitrate, into: &buf)
        FfiConverterOptionUInt8.write(value.quality, into: &buf)
        FfiConverterOptionUInt8.write(value.expectedLoss, into: &buf)
        FfiConverterOptionUInt64.write(value.volume, into: &buf)
        FfiConverterOptionUInt8.write(value.spatialPosition, into: &buf)
        FfiConverterOptionBool.write(value.denoise, into: &buf)
        FfiConverterOptionBool.write(value.record, into: &buf)
        FfiConverterOptionString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.group, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeConfigureParams_lift(_ buf: RustBuffer) throws -> AudioBridgeConfigureParams {
    return try FfiConverterTypeAudioBridgeConfigureParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeConfigureParams_lower(_ value: AudioBridgeConfigureParams) -> RustBuffer {
    return FfiConverterTypeAudioBridgeConfigureParams.lower(value)
}


public struct AudioBridgeCreateParams {
    public let room: JanusId?
    public let permanent: Bool?
    public let description: String?
    public let secret: String?
    public let pin: String?
    public let isPrivate: Bool?
    public let allowed: [String]?
    public let samplingRate: UInt64?
    public let spatialAudio: Bool?
    public let audiolevelExt: Bool?
    public let audiolevelEvent: Bool?
    public let audioActivePackets: UInt64?
    public let defaultExpectedloss: UInt64?
    public let defaultBitrate: UInt64?
    public let record: Bool?
    public let recordFile: String?
    public let recordDir: String?
    public let mjrs: Bool?
    public let mjrsDir: String?
    public let allowRtpParticipants: Bool?
    public let groups: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId? = nil, permanent: Bool? = nil, description: String? = nil, secret: String? = nil, pin: String? = nil, isPrivate: Bool? = nil, allowed: [String]? = nil, samplingRate: UInt64? = nil, spatialAudio: Bool? = nil, audiolevelExt: Bool? = nil, audiolevelEvent: Bool? = nil, audioActivePackets: UInt64? = nil, defaultExpectedloss: UInt64? = nil, defaultBitrate: UInt64? = nil, record: Bool? = nil, recordFile: String? = nil, recordDir: String? = nil, mjrs: Bool? = nil, mjrsDir: String? = nil, allowRtpParticipants: Bool? = nil, groups: [String]? = nil) {
        self.room = room
        self.permanent = permanent
        self.description = description
        self.secret = secret
        self.pin = pin
        self.isPrivate = isPrivate
        self.allowed = allowed
        self.samplingRate = samplingRate
        self.spatialAudio = spatialAudio
        self.audiolevelExt = audiolevelExt
        self.audiolevelEvent = audiolevelEvent
        self.audioActivePackets = audioActivePackets
        self.defaultExpectedloss = defaultExpectedloss
        self.defaultBitrate = defaultBitrate
        self.record = record
        self.recordFile = recordFile
        self.recordDir = recordDir
        self.mjrs = mjrs
        self.mjrsDir = mjrsDir
        self.allowRtpParticipants = allowRtpParticipants
        self.groups = groups
    }
}

#if compiler(>=6)
extension AudioBridgeCreateParams: Sendable {}
#endif


extension AudioBridgeCreateParams: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeCreateParams, rhs: AudioBridgeCreateParams) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.permanent != rhs.permanent {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.pin != rhs.pin {
            return false
        }
        if lhs.isPrivate != rhs.isPrivate {
            return false
        }
        if lhs.allowed != rhs.allowed {
            return false
        }
        if lhs.samplingRate != rhs.samplingRate {
            return false
        }
        if lhs.spatialAudio != rhs.spatialAudio {
            return false
        }
        if lhs.audiolevelExt != rhs.audiolevelExt {
            return false
        }
        if lhs.audiolevelEvent != rhs.audiolevelEvent {
            return false
        }
        if lhs.audioActivePackets != rhs.audioActivePackets {
            return false
        }
        if lhs.defaultExpectedloss != rhs.defaultExpectedloss {
            return false
        }
        if lhs.defaultBitrate != rhs.defaultBitrate {
            return false
        }
        if lhs.record != rhs.record {
            return false
        }
        if lhs.recordFile != rhs.recordFile {
            return false
        }
        if lhs.recordDir != rhs.recordDir {
            return false
        }
        if lhs.mjrs != rhs.mjrs {
            return false
        }
        if lhs.mjrsDir != rhs.mjrsDir {
            return false
        }
        if lhs.allowRtpParticipants != rhs.allowRtpParticipants {
            return false
        }
        if lhs.groups != rhs.groups {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(permanent)
        hasher.combine(description)
        hasher.combine(secret)
        hasher.combine(pin)
        hasher.combine(isPrivate)
        hasher.combine(allowed)
        hasher.combine(samplingRate)
        hasher.combine(spatialAudio)
        hasher.combine(audiolevelExt)
        hasher.combine(audiolevelEvent)
        hasher.combine(audioActivePackets)
        hasher.combine(defaultExpectedloss)
        hasher.combine(defaultBitrate)
        hasher.combine(record)
        hasher.combine(recordFile)
        hasher.combine(recordDir)
        hasher.combine(mjrs)
        hasher.combine(mjrsDir)
        hasher.combine(allowRtpParticipants)
        hasher.combine(groups)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeCreateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeCreateParams {
        return
            try AudioBridgeCreateParams(
                room: FfiConverterOptionTypeJanusId.read(from: &buf), 
                permanent: FfiConverterOptionBool.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                secret: FfiConverterOptionString.read(from: &buf), 
                pin: FfiConverterOptionString.read(from: &buf), 
                isPrivate: FfiConverterOptionBool.read(from: &buf), 
                allowed: FfiConverterOptionSequenceString.read(from: &buf), 
                samplingRate: FfiConverterOptionUInt64.read(from: &buf), 
                spatialAudio: FfiConverterOptionBool.read(from: &buf), 
                audiolevelExt: FfiConverterOptionBool.read(from: &buf), 
                audiolevelEvent: FfiConverterOptionBool.read(from: &buf), 
                audioActivePackets: FfiConverterOptionUInt64.read(from: &buf), 
                defaultExpectedloss: FfiConverterOptionUInt64.read(from: &buf), 
                defaultBitrate: FfiConverterOptionUInt64.read(from: &buf), 
                record: FfiConverterOptionBool.read(from: &buf), 
                recordFile: FfiConverterOptionString.read(from: &buf), 
                recordDir: FfiConverterOptionString.read(from: &buf), 
                mjrs: FfiConverterOptionBool.read(from: &buf), 
                mjrsDir: FfiConverterOptionString.read(from: &buf), 
                allowRtpParticipants: FfiConverterOptionBool.read(from: &buf), 
                groups: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeCreateParams, into buf: inout [UInt8]) {
        FfiConverterOptionTypeJanusId.write(value.room, into: &buf)
        FfiConverterOptionBool.write(value.permanent, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.secret, into: &buf)
        FfiConverterOptionString.write(value.pin, into: &buf)
        FfiConverterOptionBool.write(value.isPrivate, into: &buf)
        FfiConverterOptionSequenceString.write(value.allowed, into: &buf)
        FfiConverterOptionUInt64.write(value.samplingRate, into: &buf)
        FfiConverterOptionBool.write(value.spatialAudio, into: &buf)
        FfiConverterOptionBool.write(value.audiolevelExt, into: &buf)
        FfiConverterOptionBool.write(value.audiolevelEvent, into: &buf)
        FfiConverterOptionUInt64.write(value.audioActivePackets, into: &buf)
        FfiConverterOptionUInt64.write(value.defaultExpectedloss, into: &buf)
        FfiConverterOptionUInt64.write(value.defaultBitrate, into: &buf)
        FfiConverterOptionBool.write(value.record, into: &buf)
        FfiConverterOptionString.write(value.recordFile, into: &buf)
        FfiConverterOptionString.write(value.recordDir, into: &buf)
        FfiConverterOptionBool.write(value.mjrs, into: &buf)
        FfiConverterOptionString.write(value.mjrsDir, into: &buf)
        FfiConverterOptionBool.write(value.allowRtpParticipants, into: &buf)
        FfiConverterOptionSequenceString.write(value.groups, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeCreateParams_lift(_ buf: RustBuffer) throws -> AudioBridgeCreateParams {
    return try FfiConverterTypeAudioBridgeCreateParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeCreateParams_lower(_ value: AudioBridgeCreateParams) -> RustBuffer {
    return FfiConverterTypeAudioBridgeCreateParams.lower(value)
}


public struct AudioBridgeJoinParams {
    public let room: JanusId
    public let optional: AudioBridgeJoinParamsOptional

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId, optional: AudioBridgeJoinParamsOptional) {
        self.room = room
        self.optional = optional
    }
}

#if compiler(>=6)
extension AudioBridgeJoinParams: Sendable {}
#endif


extension AudioBridgeJoinParams: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeJoinParams, rhs: AudioBridgeJoinParams) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.optional != rhs.optional {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(optional)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeJoinParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeJoinParams {
        return
            try AudioBridgeJoinParams(
                room: FfiConverterTypeJanusId.read(from: &buf), 
                optional: FfiConverterTypeAudioBridgeJoinParamsOptional.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeJoinParams, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterTypeAudioBridgeJoinParamsOptional.write(value.optional, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeJoinParams_lift(_ buf: RustBuffer) throws -> AudioBridgeJoinParams {
    return try FfiConverterTypeAudioBridgeJoinParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeJoinParams_lower(_ value: AudioBridgeJoinParams) -> RustBuffer {
    return FfiConverterTypeAudioBridgeJoinParams.lower(value)
}


public struct AudioBridgeJoinParamsOptional {
    public let id: JanusId?
    public let group: String?
    public let pin: String?
    public let display: String?
    public let token: String?
    public let muted: Bool?
    public let suspended: Bool?
    public let pauseEvents: Bool?
    public let codec: AudioBridgeCodec?
    public let bitrate: UInt64?
    public let quality: UInt8?
    public let expectedLoss: UInt8?
    public let volume: UInt64?
    public let spatialPosition: UInt8?
    public let secret: String?
    public let audioLevelAverage: UInt64?
    public let audioActivePackets: UInt64?
    public let record: Bool?
    public let filename: String?
    public let generateOffer: Bool?
    public let rtp: AudioBridgeRtp?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: JanusId? = nil, group: String? = nil, pin: String? = nil, display: String? = nil, token: String? = nil, muted: Bool? = nil, suspended: Bool? = nil, pauseEvents: Bool? = nil, codec: AudioBridgeCodec? = nil, bitrate: UInt64? = nil, quality: UInt8? = nil, expectedLoss: UInt8? = nil, volume: UInt64? = nil, spatialPosition: UInt8? = nil, secret: String? = nil, audioLevelAverage: UInt64? = nil, audioActivePackets: UInt64? = nil, record: Bool? = nil, filename: String? = nil, generateOffer: Bool? = nil, rtp: AudioBridgeRtp? = nil) {
        self.id = id
        self.group = group
        self.pin = pin
        self.display = display
        self.token = token
        self.muted = muted
        self.suspended = suspended
        self.pauseEvents = pauseEvents
        self.codec = codec
        self.bitrate = bitrate
        self.quality = quality
        self.expectedLoss = expectedLoss
        self.volume = volume
        self.spatialPosition = spatialPosition
        self.secret = secret
        self.audioLevelAverage = audioLevelAverage
        self.audioActivePackets = audioActivePackets
        self.record = record
        self.filename = filename
        self.generateOffer = generateOffer
        self.rtp = rtp
    }
}

#if compiler(>=6)
extension AudioBridgeJoinParamsOptional: Sendable {}
#endif


extension AudioBridgeJoinParamsOptional: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeJoinParamsOptional, rhs: AudioBridgeJoinParamsOptional) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.group != rhs.group {
            return false
        }
        if lhs.pin != rhs.pin {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        if lhs.muted != rhs.muted {
            return false
        }
        if lhs.suspended != rhs.suspended {
            return false
        }
        if lhs.pauseEvents != rhs.pauseEvents {
            return false
        }
        if lhs.codec != rhs.codec {
            return false
        }
        if lhs.bitrate != rhs.bitrate {
            return false
        }
        if lhs.quality != rhs.quality {
            return false
        }
        if lhs.expectedLoss != rhs.expectedLoss {
            return false
        }
        if lhs.volume != rhs.volume {
            return false
        }
        if lhs.spatialPosition != rhs.spatialPosition {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.audioLevelAverage != rhs.audioLevelAverage {
            return false
        }
        if lhs.audioActivePackets != rhs.audioActivePackets {
            return false
        }
        if lhs.record != rhs.record {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        if lhs.generateOffer != rhs.generateOffer {
            return false
        }
        if lhs.rtp != rhs.rtp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(group)
        hasher.combine(pin)
        hasher.combine(display)
        hasher.combine(token)
        hasher.combine(muted)
        hasher.combine(suspended)
        hasher.combine(pauseEvents)
        hasher.combine(codec)
        hasher.combine(bitrate)
        hasher.combine(quality)
        hasher.combine(expectedLoss)
        hasher.combine(volume)
        hasher.combine(spatialPosition)
        hasher.combine(secret)
        hasher.combine(audioLevelAverage)
        hasher.combine(audioActivePackets)
        hasher.combine(record)
        hasher.combine(filename)
        hasher.combine(generateOffer)
        hasher.combine(rtp)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeJoinParamsOptional: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeJoinParamsOptional {
        return
            try AudioBridgeJoinParamsOptional(
                id: FfiConverterOptionTypeJanusId.read(from: &buf), 
                group: FfiConverterOptionString.read(from: &buf), 
                pin: FfiConverterOptionString.read(from: &buf), 
                display: FfiConverterOptionString.read(from: &buf), 
                token: FfiConverterOptionString.read(from: &buf), 
                muted: FfiConverterOptionBool.read(from: &buf), 
                suspended: FfiConverterOptionBool.read(from: &buf), 
                pauseEvents: FfiConverterOptionBool.read(from: &buf), 
                codec: FfiConverterOptionTypeAudioBridgeCodec.read(from: &buf), 
                bitrate: FfiConverterOptionUInt64.read(from: &buf), 
                quality: FfiConverterOptionUInt8.read(from: &buf), 
                expectedLoss: FfiConverterOptionUInt8.read(from: &buf), 
                volume: FfiConverterOptionUInt64.read(from: &buf), 
                spatialPosition: FfiConverterOptionUInt8.read(from: &buf), 
                secret: FfiConverterOptionString.read(from: &buf), 
                audioLevelAverage: FfiConverterOptionUInt64.read(from: &buf), 
                audioActivePackets: FfiConverterOptionUInt64.read(from: &buf), 
                record: FfiConverterOptionBool.read(from: &buf), 
                filename: FfiConverterOptionString.read(from: &buf), 
                generateOffer: FfiConverterOptionBool.read(from: &buf), 
                rtp: FfiConverterOptionTypeAudioBridgeRTP.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeJoinParamsOptional, into buf: inout [UInt8]) {
        FfiConverterOptionTypeJanusId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.group, into: &buf)
        FfiConverterOptionString.write(value.pin, into: &buf)
        FfiConverterOptionString.write(value.display, into: &buf)
        FfiConverterOptionString.write(value.token, into: &buf)
        FfiConverterOptionBool.write(value.muted, into: &buf)
        FfiConverterOptionBool.write(value.suspended, into: &buf)
        FfiConverterOptionBool.write(value.pauseEvents, into: &buf)
        FfiConverterOptionTypeAudioBridgeCodec.write(value.codec, into: &buf)
        FfiConverterOptionUInt64.write(value.bitrate, into: &buf)
        FfiConverterOptionUInt8.write(value.quality, into: &buf)
        FfiConverterOptionUInt8.write(value.expectedLoss, into: &buf)
        FfiConverterOptionUInt64.write(value.volume, into: &buf)
        FfiConverterOptionUInt8.write(value.spatialPosition, into: &buf)
        FfiConverterOptionString.write(value.secret, into: &buf)
        FfiConverterOptionUInt64.write(value.audioLevelAverage, into: &buf)
        FfiConverterOptionUInt64.write(value.audioActivePackets, into: &buf)
        FfiConverterOptionBool.write(value.record, into: &buf)
        FfiConverterOptionString.write(value.filename, into: &buf)
        FfiConverterOptionBool.write(value.generateOffer, into: &buf)
        FfiConverterOptionTypeAudioBridgeRTP.write(value.rtp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeJoinParamsOptional_lift(_ buf: RustBuffer) throws -> AudioBridgeJoinParamsOptional {
    return try FfiConverterTypeAudioBridgeJoinParamsOptional.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeJoinParamsOptional_lower(_ value: AudioBridgeJoinParamsOptional) -> RustBuffer {
    return FfiConverterTypeAudioBridgeJoinParamsOptional.lower(value)
}


public struct AudioBridgeListParticipantsRsp {
    public let room: JanusId
    public let participants: [AudioBridgeParticipant]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId, participants: [AudioBridgeParticipant]) {
        self.room = room
        self.participants = participants
    }
}

#if compiler(>=6)
extension AudioBridgeListParticipantsRsp: Sendable {}
#endif


extension AudioBridgeListParticipantsRsp: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeListParticipantsRsp, rhs: AudioBridgeListParticipantsRsp) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.participants != rhs.participants {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(participants)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeListParticipantsRsp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeListParticipantsRsp {
        return
            try AudioBridgeListParticipantsRsp(
                room: FfiConverterTypeJanusId.read(from: &buf), 
                participants: FfiConverterSequenceTypeAudioBridgeParticipant.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeListParticipantsRsp, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterSequenceTypeAudioBridgeParticipant.write(value.participants, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeListParticipantsRsp_lift(_ buf: RustBuffer) throws -> AudioBridgeListParticipantsRsp {
    return try FfiConverterTypeAudioBridgeListParticipantsRsp.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeListParticipantsRsp_lower(_ value: AudioBridgeListParticipantsRsp) -> RustBuffer {
    return FfiConverterTypeAudioBridgeListParticipantsRsp.lower(value)
}


public struct AudioBridgeMuteParams {
    public let id: JanusId
    public let room: JanusId
    public let secret: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: JanusId, room: JanusId, secret: String? = nil) {
        self.id = id
        self.room = room
        self.secret = secret
    }
}

#if compiler(>=6)
extension AudioBridgeMuteParams: Sendable {}
#endif


extension AudioBridgeMuteParams: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeMuteParams, rhs: AudioBridgeMuteParams) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.room != rhs.room {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(room)
        hasher.combine(secret)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeMuteParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeMuteParams {
        return
            try AudioBridgeMuteParams(
                id: FfiConverterTypeJanusId.read(from: &buf), 
                room: FfiConverterTypeJanusId.read(from: &buf), 
                secret: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeMuteParams, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.id, into: &buf)
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterOptionString.write(value.secret, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeMuteParams_lift(_ buf: RustBuffer) throws -> AudioBridgeMuteParams {
    return try FfiConverterTypeAudioBridgeMuteParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeMuteParams_lower(_ value: AudioBridgeMuteParams) -> RustBuffer {
    return FfiConverterTypeAudioBridgeMuteParams.lower(value)
}


public struct AudioBridgeParticipant {
    public let id: JanusId
    public let display: String?
    public let setup: Bool
    public let muted: Bool
    public let suspended: Bool?
    public let talking: Bool?
    public let spatialPosition: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: JanusId, display: String?, setup: Bool, muted: Bool, suspended: Bool?, talking: Bool?, spatialPosition: UInt64?) {
        self.id = id
        self.display = display
        self.setup = setup
        self.muted = muted
        self.suspended = suspended
        self.talking = talking
        self.spatialPosition = spatialPosition
    }
}

#if compiler(>=6)
extension AudioBridgeParticipant: Sendable {}
#endif


extension AudioBridgeParticipant: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeParticipant, rhs: AudioBridgeParticipant) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.setup != rhs.setup {
            return false
        }
        if lhs.muted != rhs.muted {
            return false
        }
        if lhs.suspended != rhs.suspended {
            return false
        }
        if lhs.talking != rhs.talking {
            return false
        }
        if lhs.spatialPosition != rhs.spatialPosition {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(display)
        hasher.combine(setup)
        hasher.combine(muted)
        hasher.combine(suspended)
        hasher.combine(talking)
        hasher.combine(spatialPosition)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeParticipant: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeParticipant {
        return
            try AudioBridgeParticipant(
                id: FfiConverterTypeJanusId.read(from: &buf), 
                display: FfiConverterOptionString.read(from: &buf), 
                setup: FfiConverterBool.read(from: &buf), 
                muted: FfiConverterBool.read(from: &buf), 
                suspended: FfiConverterOptionBool.read(from: &buf), 
                talking: FfiConverterOptionBool.read(from: &buf), 
                spatialPosition: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeParticipant, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.display, into: &buf)
        FfiConverterBool.write(value.setup, into: &buf)
        FfiConverterBool.write(value.muted, into: &buf)
        FfiConverterOptionBool.write(value.suspended, into: &buf)
        FfiConverterOptionBool.write(value.talking, into: &buf)
        FfiConverterOptionUInt64.write(value.spatialPosition, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeParticipant_lift(_ buf: RustBuffer) throws -> AudioBridgeParticipant {
    return try FfiConverterTypeAudioBridgeParticipant.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeParticipant_lower(_ value: AudioBridgeParticipant) -> RustBuffer {
    return FfiConverterTypeAudioBridgeParticipant.lower(value)
}


public struct AudioBridgeRtp {
    public let required: AudioBridgeRtpRequired
    public let optional: AudioBridgeRtpOptional

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(required: AudioBridgeRtpRequired, optional: AudioBridgeRtpOptional) {
        self.required = required
        self.optional = optional
    }
}

#if compiler(>=6)
extension AudioBridgeRtp: Sendable {}
#endif


extension AudioBridgeRtp: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeRtp, rhs: AudioBridgeRtp) -> Bool {
        if lhs.required != rhs.required {
            return false
        }
        if lhs.optional != rhs.optional {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(required)
        hasher.combine(optional)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeRTP: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeRtp {
        return
            try AudioBridgeRtp(
                required: FfiConverterTypeAudioBridgeRTPRequired.read(from: &buf), 
                optional: FfiConverterTypeAudioBridgeRTPOptional.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeRtp, into buf: inout [UInt8]) {
        FfiConverterTypeAudioBridgeRTPRequired.write(value.required, into: &buf)
        FfiConverterTypeAudioBridgeRTPOptional.write(value.optional, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeRTP_lift(_ buf: RustBuffer) throws -> AudioBridgeRtp {
    return try FfiConverterTypeAudioBridgeRTP.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeRTP_lower(_ value: AudioBridgeRtp) -> RustBuffer {
    return FfiConverterTypeAudioBridgeRTP.lower(value)
}


public struct AudioBridgeRtpOptional {
    public let payloadType: String?
    public let audiolevelExt: String?
    public let fec: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payloadType: String? = nil, audiolevelExt: String? = nil, fec: Bool? = nil) {
        self.payloadType = payloadType
        self.audiolevelExt = audiolevelExt
        self.fec = fec
    }
}

#if compiler(>=6)
extension AudioBridgeRtpOptional: Sendable {}
#endif


extension AudioBridgeRtpOptional: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeRtpOptional, rhs: AudioBridgeRtpOptional) -> Bool {
        if lhs.payloadType != rhs.payloadType {
            return false
        }
        if lhs.audiolevelExt != rhs.audiolevelExt {
            return false
        }
        if lhs.fec != rhs.fec {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payloadType)
        hasher.combine(audiolevelExt)
        hasher.combine(fec)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeRTPOptional: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeRtpOptional {
        return
            try AudioBridgeRtpOptional(
                payloadType: FfiConverterOptionString.read(from: &buf), 
                audiolevelExt: FfiConverterOptionString.read(from: &buf), 
                fec: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeRtpOptional, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.payloadType, into: &buf)
        FfiConverterOptionString.write(value.audiolevelExt, into: &buf)
        FfiConverterOptionBool.write(value.fec, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeRTPOptional_lift(_ buf: RustBuffer) throws -> AudioBridgeRtpOptional {
    return try FfiConverterTypeAudioBridgeRTPOptional.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeRTPOptional_lower(_ value: AudioBridgeRtpOptional) -> RustBuffer {
    return FfiConverterTypeAudioBridgeRTPOptional.lower(value)
}


public struct AudioBridgeRtpRequired {
    public let ip: String
    public let port: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ip: String, port: UInt16) {
        self.ip = ip
        self.port = port
    }
}

#if compiler(>=6)
extension AudioBridgeRtpRequired: Sendable {}
#endif


extension AudioBridgeRtpRequired: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeRtpRequired, rhs: AudioBridgeRtpRequired) -> Bool {
        if lhs.ip != rhs.ip {
            return false
        }
        if lhs.port != rhs.port {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ip)
        hasher.combine(port)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeRTPRequired: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeRtpRequired {
        return
            try AudioBridgeRtpRequired(
                ip: FfiConverterString.read(from: &buf), 
                port: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeRtpRequired, into buf: inout [UInt8]) {
        FfiConverterString.write(value.ip, into: &buf)
        FfiConverterUInt16.write(value.port, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeRTPRequired_lift(_ buf: RustBuffer) throws -> AudioBridgeRtpRequired {
    return try FfiConverterTypeAudioBridgeRTPRequired.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeRTPRequired_lower(_ value: AudioBridgeRtpRequired) -> RustBuffer {
    return FfiConverterTypeAudioBridgeRTPRequired.lower(value)
}


public struct AudioBridgeRoomCreatedRsp {
    public let room: JanusId
    public let permanent: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId, permanent: Bool) {
        self.room = room
        self.permanent = permanent
    }
}

#if compiler(>=6)
extension AudioBridgeRoomCreatedRsp: Sendable {}
#endif


extension AudioBridgeRoomCreatedRsp: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeRoomCreatedRsp, rhs: AudioBridgeRoomCreatedRsp) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.permanent != rhs.permanent {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(permanent)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeRoomCreatedRsp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeRoomCreatedRsp {
        return
            try AudioBridgeRoomCreatedRsp(
                room: FfiConverterTypeJanusId.read(from: &buf), 
                permanent: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeRoomCreatedRsp, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterBool.write(value.permanent, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeRoomCreatedRsp_lift(_ buf: RustBuffer) throws -> AudioBridgeRoomCreatedRsp {
    return try FfiConverterTypeAudioBridgeRoomCreatedRsp.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeRoomCreatedRsp_lower(_ value: AudioBridgeRoomCreatedRsp) -> RustBuffer {
    return FfiConverterTypeAudioBridgeRoomCreatedRsp.lower(value)
}


public struct Candidate {
    public let candidate: String
    public let sdpMid: String
    public let sdpMlineIndex: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(candidate: String, sdpMid: String, sdpMlineIndex: UInt32) {
        self.candidate = candidate
        self.sdpMid = sdpMid
        self.sdpMlineIndex = sdpMlineIndex
    }
}

#if compiler(>=6)
extension Candidate: Sendable {}
#endif


extension Candidate: Equatable, Hashable {
    public static func ==(lhs: Candidate, rhs: Candidate) -> Bool {
        if lhs.candidate != rhs.candidate {
            return false
        }
        if lhs.sdpMid != rhs.sdpMid {
            return false
        }
        if lhs.sdpMlineIndex != rhs.sdpMlineIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(candidate)
        hasher.combine(sdpMid)
        hasher.combine(sdpMlineIndex)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCandidate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Candidate {
        return
            try Candidate(
                candidate: FfiConverterString.read(from: &buf), 
                sdpMid: FfiConverterString.read(from: &buf), 
                sdpMlineIndex: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Candidate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.candidate, into: &buf)
        FfiConverterString.write(value.sdpMid, into: &buf)
        FfiConverterUInt32.write(value.sdpMlineIndex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCandidate_lift(_ buf: RustBuffer) throws -> Candidate {
    return try FfiConverterTypeCandidate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCandidate_lower(_ value: Candidate) -> RustBuffer {
    return FfiConverterTypeCandidate.lower(value)
}


public struct Config {
    /**
     * Server URL
     */
    public let url: String
    /**
     * Buffer capacity
     */
    public let capacity: UInt16
    /**
     * API secret
     */
    public let apisecret: String?
    public let serverRoot: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Server URL
         */url: String, 
        /**
         * Buffer capacity
         */capacity: UInt16, 
        /**
         * API secret
         */apisecret: String? = nil, serverRoot: String = "janus") {
        self.url = url
        self.capacity = capacity
        self.apisecret = apisecret
        self.serverRoot = serverRoot
    }
}

#if compiler(>=6)
extension Config: Sendable {}
#endif


extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.capacity != rhs.capacity {
            return false
        }
        if lhs.apisecret != rhs.apisecret {
            return false
        }
        if lhs.serverRoot != rhs.serverRoot {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(capacity)
        hasher.combine(apisecret)
        hasher.combine(serverRoot)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                url: FfiConverterString.read(from: &buf), 
                capacity: FfiConverterUInt16.read(from: &buf), 
                apisecret: FfiConverterOptionString.read(from: &buf), 
                serverRoot: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterUInt16.write(value.capacity, into: &buf)
        FfiConverterOptionString.write(value.apisecret, into: &buf)
        FfiConverterString.write(value.serverRoot, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct ConfiguredStream {
    public let mediaType: String
    public let mindex: UInt64
    public let mid: String
    public let disabled: Bool
    public let codec: String
    public let stereo: Bool
    public let fec: Bool
    public let dtx: Bool
    public let h264Profile: String?
    public let vp9Profile: String?
    public let moderated: Bool
    public let simulcast: Bool
    public let svc: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mediaType: String, mindex: UInt64, mid: String, disabled: Bool, codec: String, stereo: Bool, fec: Bool, dtx: Bool, h264Profile: String?, vp9Profile: String?, moderated: Bool, simulcast: Bool, svc: Bool) {
        self.mediaType = mediaType
        self.mindex = mindex
        self.mid = mid
        self.disabled = disabled
        self.codec = codec
        self.stereo = stereo
        self.fec = fec
        self.dtx = dtx
        self.h264Profile = h264Profile
        self.vp9Profile = vp9Profile
        self.moderated = moderated
        self.simulcast = simulcast
        self.svc = svc
    }
}

#if compiler(>=6)
extension ConfiguredStream: Sendable {}
#endif


extension ConfiguredStream: Equatable, Hashable {
    public static func ==(lhs: ConfiguredStream, rhs: ConfiguredStream) -> Bool {
        if lhs.mediaType != rhs.mediaType {
            return false
        }
        if lhs.mindex != rhs.mindex {
            return false
        }
        if lhs.mid != rhs.mid {
            return false
        }
        if lhs.disabled != rhs.disabled {
            return false
        }
        if lhs.codec != rhs.codec {
            return false
        }
        if lhs.stereo != rhs.stereo {
            return false
        }
        if lhs.fec != rhs.fec {
            return false
        }
        if lhs.dtx != rhs.dtx {
            return false
        }
        if lhs.h264Profile != rhs.h264Profile {
            return false
        }
        if lhs.vp9Profile != rhs.vp9Profile {
            return false
        }
        if lhs.moderated != rhs.moderated {
            return false
        }
        if lhs.simulcast != rhs.simulcast {
            return false
        }
        if lhs.svc != rhs.svc {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mediaType)
        hasher.combine(mindex)
        hasher.combine(mid)
        hasher.combine(disabled)
        hasher.combine(codec)
        hasher.combine(stereo)
        hasher.combine(fec)
        hasher.combine(dtx)
        hasher.combine(h264Profile)
        hasher.combine(vp9Profile)
        hasher.combine(moderated)
        hasher.combine(simulcast)
        hasher.combine(svc)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfiguredStream: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfiguredStream {
        return
            try ConfiguredStream(
                mediaType: FfiConverterString.read(from: &buf), 
                mindex: FfiConverterUInt64.read(from: &buf), 
                mid: FfiConverterString.read(from: &buf), 
                disabled: FfiConverterBool.read(from: &buf), 
                codec: FfiConverterString.read(from: &buf), 
                stereo: FfiConverterBool.read(from: &buf), 
                fec: FfiConverterBool.read(from: &buf), 
                dtx: FfiConverterBool.read(from: &buf), 
                h264Profile: FfiConverterOptionString.read(from: &buf), 
                vp9Profile: FfiConverterOptionString.read(from: &buf), 
                moderated: FfiConverterBool.read(from: &buf), 
                simulcast: FfiConverterBool.read(from: &buf), 
                svc: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ConfiguredStream, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mediaType, into: &buf)
        FfiConverterUInt64.write(value.mindex, into: &buf)
        FfiConverterString.write(value.mid, into: &buf)
        FfiConverterBool.write(value.disabled, into: &buf)
        FfiConverterString.write(value.codec, into: &buf)
        FfiConverterBool.write(value.stereo, into: &buf)
        FfiConverterBool.write(value.fec, into: &buf)
        FfiConverterBool.write(value.dtx, into: &buf)
        FfiConverterOptionString.write(value.h264Profile, into: &buf)
        FfiConverterOptionString.write(value.vp9Profile, into: &buf)
        FfiConverterBool.write(value.moderated, into: &buf)
        FfiConverterBool.write(value.simulcast, into: &buf)
        FfiConverterBool.write(value.svc, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfiguredStream_lift(_ buf: RustBuffer) throws -> ConfiguredStream {
    return try FfiConverterTypeConfiguredStream.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfiguredStream_lower(_ value: ConfiguredStream) -> RustBuffer {
    return FfiConverterTypeConfiguredStream.lower(value)
}


public struct EchoTestStartParams {
    public let audio: Bool?
    public let video: Bool?
    public let bitrate: UInt32?
    public let record: Bool?
    public let filename: String?
    public let substream: UInt32?
    public let temporal: UInt32?
    public let fallback: UInt32?
    public let svc: Bool?
    public let spatialLayer: UInt32?
    public let temporalLayer: UInt32?
    public let audiocodec: String?
    public let videocodec: String?
    public let videoprofile: String?
    public let opusred: Bool?
    public let minDelay: Int32?
    public let maxDelay: Int32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(audio: Bool? = nil, video: Bool? = nil, bitrate: UInt32? = nil, record: Bool? = nil, filename: String? = nil, substream: UInt32? = nil, temporal: UInt32? = nil, fallback: UInt32? = nil, svc: Bool? = nil, spatialLayer: UInt32? = nil, temporalLayer: UInt32? = nil, audiocodec: String? = nil, videocodec: String? = nil, videoprofile: String? = nil, opusred: Bool? = nil, minDelay: Int32? = nil, maxDelay: Int32? = nil) {
        self.audio = audio
        self.video = video
        self.bitrate = bitrate
        self.record = record
        self.filename = filename
        self.substream = substream
        self.temporal = temporal
        self.fallback = fallback
        self.svc = svc
        self.spatialLayer = spatialLayer
        self.temporalLayer = temporalLayer
        self.audiocodec = audiocodec
        self.videocodec = videocodec
        self.videoprofile = videoprofile
        self.opusred = opusred
        self.minDelay = minDelay
        self.maxDelay = maxDelay
    }
}

#if compiler(>=6)
extension EchoTestStartParams: Sendable {}
#endif


extension EchoTestStartParams: Equatable, Hashable {
    public static func ==(lhs: EchoTestStartParams, rhs: EchoTestStartParams) -> Bool {
        if lhs.audio != rhs.audio {
            return false
        }
        if lhs.video != rhs.video {
            return false
        }
        if lhs.bitrate != rhs.bitrate {
            return false
        }
        if lhs.record != rhs.record {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        if lhs.substream != rhs.substream {
            return false
        }
        if lhs.temporal != rhs.temporal {
            return false
        }
        if lhs.fallback != rhs.fallback {
            return false
        }
        if lhs.svc != rhs.svc {
            return false
        }
        if lhs.spatialLayer != rhs.spatialLayer {
            return false
        }
        if lhs.temporalLayer != rhs.temporalLayer {
            return false
        }
        if lhs.audiocodec != rhs.audiocodec {
            return false
        }
        if lhs.videocodec != rhs.videocodec {
            return false
        }
        if lhs.videoprofile != rhs.videoprofile {
            return false
        }
        if lhs.opusred != rhs.opusred {
            return false
        }
        if lhs.minDelay != rhs.minDelay {
            return false
        }
        if lhs.maxDelay != rhs.maxDelay {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(audio)
        hasher.combine(video)
        hasher.combine(bitrate)
        hasher.combine(record)
        hasher.combine(filename)
        hasher.combine(substream)
        hasher.combine(temporal)
        hasher.combine(fallback)
        hasher.combine(svc)
        hasher.combine(spatialLayer)
        hasher.combine(temporalLayer)
        hasher.combine(audiocodec)
        hasher.combine(videocodec)
        hasher.combine(videoprofile)
        hasher.combine(opusred)
        hasher.combine(minDelay)
        hasher.combine(maxDelay)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEchoTestStartParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EchoTestStartParams {
        return
            try EchoTestStartParams(
                audio: FfiConverterOptionBool.read(from: &buf), 
                video: FfiConverterOptionBool.read(from: &buf), 
                bitrate: FfiConverterOptionUInt32.read(from: &buf), 
                record: FfiConverterOptionBool.read(from: &buf), 
                filename: FfiConverterOptionString.read(from: &buf), 
                substream: FfiConverterOptionUInt32.read(from: &buf), 
                temporal: FfiConverterOptionUInt32.read(from: &buf), 
                fallback: FfiConverterOptionUInt32.read(from: &buf), 
                svc: FfiConverterOptionBool.read(from: &buf), 
                spatialLayer: FfiConverterOptionUInt32.read(from: &buf), 
                temporalLayer: FfiConverterOptionUInt32.read(from: &buf), 
                audiocodec: FfiConverterOptionString.read(from: &buf), 
                videocodec: FfiConverterOptionString.read(from: &buf), 
                videoprofile: FfiConverterOptionString.read(from: &buf), 
                opusred: FfiConverterOptionBool.read(from: &buf), 
                minDelay: FfiConverterOptionInt32.read(from: &buf), 
                maxDelay: FfiConverterOptionInt32.read(from: &buf)
        )
    }

    public static func write(_ value: EchoTestStartParams, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.audio, into: &buf)
        FfiConverterOptionBool.write(value.video, into: &buf)
        FfiConverterOptionUInt32.write(value.bitrate, into: &buf)
        FfiConverterOptionBool.write(value.record, into: &buf)
        FfiConverterOptionString.write(value.filename, into: &buf)
        FfiConverterOptionUInt32.write(value.substream, into: &buf)
        FfiConverterOptionUInt32.write(value.temporal, into: &buf)
        FfiConverterOptionUInt32.write(value.fallback, into: &buf)
        FfiConverterOptionBool.write(value.svc, into: &buf)
        FfiConverterOptionUInt32.write(value.spatialLayer, into: &buf)
        FfiConverterOptionUInt32.write(value.temporalLayer, into: &buf)
        FfiConverterOptionString.write(value.audiocodec, into: &buf)
        FfiConverterOptionString.write(value.videocodec, into: &buf)
        FfiConverterOptionString.write(value.videoprofile, into: &buf)
        FfiConverterOptionBool.write(value.opusred, into: &buf)
        FfiConverterOptionInt32.write(value.minDelay, into: &buf)
        FfiConverterOptionInt32.write(value.maxDelay, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEchoTestStartParams_lift(_ buf: RustBuffer) throws -> EchoTestStartParams {
    return try FfiConverterTypeEchoTestStartParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEchoTestStartParams_lower(_ value: EchoTestStartParams) -> RustBuffer {
    return FfiConverterTypeEchoTestStartParams.lower(value)
}


public struct Jsep {
    public let jsepType: JsepType
    public let trickle: Bool?
    public let sdp: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(jsepType: JsepType, trickle: Bool? = nil, sdp: String) {
        self.jsepType = jsepType
        self.trickle = trickle
        self.sdp = sdp
    }
}

#if compiler(>=6)
extension Jsep: Sendable {}
#endif


extension Jsep: Equatable, Hashable {
    public static func ==(lhs: Jsep, rhs: Jsep) -> Bool {
        if lhs.jsepType != rhs.jsepType {
            return false
        }
        if lhs.trickle != rhs.trickle {
            return false
        }
        if lhs.sdp != rhs.sdp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(jsepType)
        hasher.combine(trickle)
        hasher.combine(sdp)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJsep: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Jsep {
        return
            try Jsep(
                jsepType: FfiConverterTypeJsepType.read(from: &buf), 
                trickle: FfiConverterOptionBool.read(from: &buf), 
                sdp: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Jsep, into buf: inout [UInt8]) {
        FfiConverterTypeJsepType.write(value.jsepType, into: &buf)
        FfiConverterOptionBool.write(value.trickle, into: &buf)
        FfiConverterString.write(value.sdp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsep_lift(_ buf: RustBuffer) throws -> Jsep {
    return try FfiConverterTypeJsep.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsep_lower(_ value: Jsep) -> RustBuffer {
    return FfiConverterTypeJsep.lower(value)
}


public struct LegacyVideoRoomAudioCodecList {
    public let codecs: [LegacyVideoRoomAudioCodec]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(codecs: [LegacyVideoRoomAudioCodec]) {
        self.codecs = codecs
    }
}

#if compiler(>=6)
extension LegacyVideoRoomAudioCodecList: Sendable {}
#endif


extension LegacyVideoRoomAudioCodecList: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomAudioCodecList, rhs: LegacyVideoRoomAudioCodecList) -> Bool {
        if lhs.codecs != rhs.codecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(codecs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomAudioCodecList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomAudioCodecList {
        return
            try LegacyVideoRoomAudioCodecList(
                codecs: FfiConverterSequenceTypeLegacyVideoRoomAudioCodec.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomAudioCodecList, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeLegacyVideoRoomAudioCodec.write(value.codecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomAudioCodecList_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomAudioCodecList {
    return try FfiConverterTypeLegacyVideoRoomAudioCodecList.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomAudioCodecList_lower(_ value: LegacyVideoRoomAudioCodecList) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomAudioCodecList.lower(value)
}


public struct LegacyVideoRoomCreateParams {
    public let adminKey: String?
    public let room: JanusId?
    public let description: String?
    public let isPrivate: Bool?
    public let allowed: [String]?
    public let secret: String?
    public let pin: String?
    public let requirePvtid: Bool?
    public let signedTokens: Bool?
    public let bitrate: UInt64?
    public let bitrateCap: Bool?
    public let firFreq: UInt64?
    public let publishers: UInt64?
    public let audiocodec: LegacyVideoRoomAudioCodecList?
    public let videocodec: LegacyVideoRoomVideoCodecList?
    public let vp9Profile: String?
    public let h264Profile: String?
    public let opusFec: Bool?
    public let opusDtx: Bool?
    public let audiolevelExt: Bool?
    public let audiolevelEvent: Bool?
    public let audioActivePackets: UInt64?
    public let audioLevelAverage: UInt64?
    public let videoorientExt: Bool?
    public let playoutdelayExt: Bool?
    public let transportWideCcExt: Bool?
    public let record: Bool?
    public let recordDir: String?
    public let lockRecord: Bool?
    public let permanent: Bool?
    public let notifyJoining: Bool?
    public let requireE2ee: Bool?
    public let dummyPublisher: Bool?
    public let dummyStreams: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(adminKey: String? = nil, room: JanusId? = nil, description: String? = nil, isPrivate: Bool? = nil, allowed: [String]? = nil, secret: String? = nil, pin: String? = nil, requirePvtid: Bool? = nil, signedTokens: Bool? = nil, bitrate: UInt64? = nil, bitrateCap: Bool? = nil, firFreq: UInt64? = nil, publishers: UInt64? = nil, audiocodec: LegacyVideoRoomAudioCodecList? = nil, videocodec: LegacyVideoRoomVideoCodecList? = nil, vp9Profile: String? = nil, h264Profile: String? = nil, opusFec: Bool? = nil, opusDtx: Bool? = nil, audiolevelExt: Bool? = nil, audiolevelEvent: Bool? = nil, audioActivePackets: UInt64? = nil, audioLevelAverage: UInt64? = nil, videoorientExt: Bool? = nil, playoutdelayExt: Bool? = nil, transportWideCcExt: Bool? = nil, record: Bool? = nil, recordDir: String? = nil, lockRecord: Bool? = nil, permanent: Bool? = nil, notifyJoining: Bool? = nil, requireE2ee: Bool? = nil, dummyPublisher: Bool? = nil, dummyStreams: Bool? = nil) {
        self.adminKey = adminKey
        self.room = room
        self.description = description
        self.isPrivate = isPrivate
        self.allowed = allowed
        self.secret = secret
        self.pin = pin
        self.requirePvtid = requirePvtid
        self.signedTokens = signedTokens
        self.bitrate = bitrate
        self.bitrateCap = bitrateCap
        self.firFreq = firFreq
        self.publishers = publishers
        self.audiocodec = audiocodec
        self.videocodec = videocodec
        self.vp9Profile = vp9Profile
        self.h264Profile = h264Profile
        self.opusFec = opusFec
        self.opusDtx = opusDtx
        self.audiolevelExt = audiolevelExt
        self.audiolevelEvent = audiolevelEvent
        self.audioActivePackets = audioActivePackets
        self.audioLevelAverage = audioLevelAverage
        self.videoorientExt = videoorientExt
        self.playoutdelayExt = playoutdelayExt
        self.transportWideCcExt = transportWideCcExt
        self.record = record
        self.recordDir = recordDir
        self.lockRecord = lockRecord
        self.permanent = permanent
        self.notifyJoining = notifyJoining
        self.requireE2ee = requireE2ee
        self.dummyPublisher = dummyPublisher
        self.dummyStreams = dummyStreams
    }
}

#if compiler(>=6)
extension LegacyVideoRoomCreateParams: Sendable {}
#endif


extension LegacyVideoRoomCreateParams: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomCreateParams, rhs: LegacyVideoRoomCreateParams) -> Bool {
        if lhs.adminKey != rhs.adminKey {
            return false
        }
        if lhs.room != rhs.room {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.isPrivate != rhs.isPrivate {
            return false
        }
        if lhs.allowed != rhs.allowed {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.pin != rhs.pin {
            return false
        }
        if lhs.requirePvtid != rhs.requirePvtid {
            return false
        }
        if lhs.signedTokens != rhs.signedTokens {
            return false
        }
        if lhs.bitrate != rhs.bitrate {
            return false
        }
        if lhs.bitrateCap != rhs.bitrateCap {
            return false
        }
        if lhs.firFreq != rhs.firFreq {
            return false
        }
        if lhs.publishers != rhs.publishers {
            return false
        }
        if lhs.audiocodec != rhs.audiocodec {
            return false
        }
        if lhs.videocodec != rhs.videocodec {
            return false
        }
        if lhs.vp9Profile != rhs.vp9Profile {
            return false
        }
        if lhs.h264Profile != rhs.h264Profile {
            return false
        }
        if lhs.opusFec != rhs.opusFec {
            return false
        }
        if lhs.opusDtx != rhs.opusDtx {
            return false
        }
        if lhs.audiolevelExt != rhs.audiolevelExt {
            return false
        }
        if lhs.audiolevelEvent != rhs.audiolevelEvent {
            return false
        }
        if lhs.audioActivePackets != rhs.audioActivePackets {
            return false
        }
        if lhs.audioLevelAverage != rhs.audioLevelAverage {
            return false
        }
        if lhs.videoorientExt != rhs.videoorientExt {
            return false
        }
        if lhs.playoutdelayExt != rhs.playoutdelayExt {
            return false
        }
        if lhs.transportWideCcExt != rhs.transportWideCcExt {
            return false
        }
        if lhs.record != rhs.record {
            return false
        }
        if lhs.recordDir != rhs.recordDir {
            return false
        }
        if lhs.lockRecord != rhs.lockRecord {
            return false
        }
        if lhs.permanent != rhs.permanent {
            return false
        }
        if lhs.notifyJoining != rhs.notifyJoining {
            return false
        }
        if lhs.requireE2ee != rhs.requireE2ee {
            return false
        }
        if lhs.dummyPublisher != rhs.dummyPublisher {
            return false
        }
        if lhs.dummyStreams != rhs.dummyStreams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(adminKey)
        hasher.combine(room)
        hasher.combine(description)
        hasher.combine(isPrivate)
        hasher.combine(allowed)
        hasher.combine(secret)
        hasher.combine(pin)
        hasher.combine(requirePvtid)
        hasher.combine(signedTokens)
        hasher.combine(bitrate)
        hasher.combine(bitrateCap)
        hasher.combine(firFreq)
        hasher.combine(publishers)
        hasher.combine(audiocodec)
        hasher.combine(videocodec)
        hasher.combine(vp9Profile)
        hasher.combine(h264Profile)
        hasher.combine(opusFec)
        hasher.combine(opusDtx)
        hasher.combine(audiolevelExt)
        hasher.combine(audiolevelEvent)
        hasher.combine(audioActivePackets)
        hasher.combine(audioLevelAverage)
        hasher.combine(videoorientExt)
        hasher.combine(playoutdelayExt)
        hasher.combine(transportWideCcExt)
        hasher.combine(record)
        hasher.combine(recordDir)
        hasher.combine(lockRecord)
        hasher.combine(permanent)
        hasher.combine(notifyJoining)
        hasher.combine(requireE2ee)
        hasher.combine(dummyPublisher)
        hasher.combine(dummyStreams)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomCreateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomCreateParams {
        return
            try LegacyVideoRoomCreateParams(
                adminKey: FfiConverterOptionString.read(from: &buf), 
                room: FfiConverterOptionTypeJanusId.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                isPrivate: FfiConverterOptionBool.read(from: &buf), 
                allowed: FfiConverterOptionSequenceString.read(from: &buf), 
                secret: FfiConverterOptionString.read(from: &buf), 
                pin: FfiConverterOptionString.read(from: &buf), 
                requirePvtid: FfiConverterOptionBool.read(from: &buf), 
                signedTokens: FfiConverterOptionBool.read(from: &buf), 
                bitrate: FfiConverterOptionUInt64.read(from: &buf), 
                bitrateCap: FfiConverterOptionBool.read(from: &buf), 
                firFreq: FfiConverterOptionUInt64.read(from: &buf), 
                publishers: FfiConverterOptionUInt64.read(from: &buf), 
                audiocodec: FfiConverterOptionTypeLegacyVideoRoomAudioCodecList.read(from: &buf), 
                videocodec: FfiConverterOptionTypeLegacyVideoRoomVideoCodecList.read(from: &buf), 
                vp9Profile: FfiConverterOptionString.read(from: &buf), 
                h264Profile: FfiConverterOptionString.read(from: &buf), 
                opusFec: FfiConverterOptionBool.read(from: &buf), 
                opusDtx: FfiConverterOptionBool.read(from: &buf), 
                audiolevelExt: FfiConverterOptionBool.read(from: &buf), 
                audiolevelEvent: FfiConverterOptionBool.read(from: &buf), 
                audioActivePackets: FfiConverterOptionUInt64.read(from: &buf), 
                audioLevelAverage: FfiConverterOptionUInt64.read(from: &buf), 
                videoorientExt: FfiConverterOptionBool.read(from: &buf), 
                playoutdelayExt: FfiConverterOptionBool.read(from: &buf), 
                transportWideCcExt: FfiConverterOptionBool.read(from: &buf), 
                record: FfiConverterOptionBool.read(from: &buf), 
                recordDir: FfiConverterOptionString.read(from: &buf), 
                lockRecord: FfiConverterOptionBool.read(from: &buf), 
                permanent: FfiConverterOptionBool.read(from: &buf), 
                notifyJoining: FfiConverterOptionBool.read(from: &buf), 
                requireE2ee: FfiConverterOptionBool.read(from: &buf), 
                dummyPublisher: FfiConverterOptionBool.read(from: &buf), 
                dummyStreams: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomCreateParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.adminKey, into: &buf)
        FfiConverterOptionTypeJanusId.write(value.room, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionBool.write(value.isPrivate, into: &buf)
        FfiConverterOptionSequenceString.write(value.allowed, into: &buf)
        FfiConverterOptionString.write(value.secret, into: &buf)
        FfiConverterOptionString.write(value.pin, into: &buf)
        FfiConverterOptionBool.write(value.requirePvtid, into: &buf)
        FfiConverterOptionBool.write(value.signedTokens, into: &buf)
        FfiConverterOptionUInt64.write(value.bitrate, into: &buf)
        FfiConverterOptionBool.write(value.bitrateCap, into: &buf)
        FfiConverterOptionUInt64.write(value.firFreq, into: &buf)
        FfiConverterOptionUInt64.write(value.publishers, into: &buf)
        FfiConverterOptionTypeLegacyVideoRoomAudioCodecList.write(value.audiocodec, into: &buf)
        FfiConverterOptionTypeLegacyVideoRoomVideoCodecList.write(value.videocodec, into: &buf)
        FfiConverterOptionString.write(value.vp9Profile, into: &buf)
        FfiConverterOptionString.write(value.h264Profile, into: &buf)
        FfiConverterOptionBool.write(value.opusFec, into: &buf)
        FfiConverterOptionBool.write(value.opusDtx, into: &buf)
        FfiConverterOptionBool.write(value.audiolevelExt, into: &buf)
        FfiConverterOptionBool.write(value.audiolevelEvent, into: &buf)
        FfiConverterOptionUInt64.write(value.audioActivePackets, into: &buf)
        FfiConverterOptionUInt64.write(value.audioLevelAverage, into: &buf)
        FfiConverterOptionBool.write(value.videoorientExt, into: &buf)
        FfiConverterOptionBool.write(value.playoutdelayExt, into: &buf)
        FfiConverterOptionBool.write(value.transportWideCcExt, into: &buf)
        FfiConverterOptionBool.write(value.record, into: &buf)
        FfiConverterOptionString.write(value.recordDir, into: &buf)
        FfiConverterOptionBool.write(value.lockRecord, into: &buf)
        FfiConverterOptionBool.write(value.permanent, into: &buf)
        FfiConverterOptionBool.write(value.notifyJoining, into: &buf)
        FfiConverterOptionBool.write(value.requireE2ee, into: &buf)
        FfiConverterOptionBool.write(value.dummyPublisher, into: &buf)
        FfiConverterOptionBool.write(value.dummyStreams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomCreateParams_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomCreateParams {
    return try FfiConverterTypeLegacyVideoRoomCreateParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomCreateParams_lower(_ value: LegacyVideoRoomCreateParams) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomCreateParams.lower(value)
}


public struct LegacyVideoRoomCreatedRsp {
    public let room: JanusId
    public let permanent: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId, permanent: Bool) {
        self.room = room
        self.permanent = permanent
    }
}

#if compiler(>=6)
extension LegacyVideoRoomCreatedRsp: Sendable {}
#endif


extension LegacyVideoRoomCreatedRsp: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomCreatedRsp, rhs: LegacyVideoRoomCreatedRsp) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.permanent != rhs.permanent {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(permanent)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomCreatedRsp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomCreatedRsp {
        return
            try LegacyVideoRoomCreatedRsp(
                room: FfiConverterTypeJanusId.read(from: &buf), 
                permanent: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomCreatedRsp, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterBool.write(value.permanent, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomCreatedRsp_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomCreatedRsp {
    return try FfiConverterTypeLegacyVideoRoomCreatedRsp.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomCreatedRsp_lower(_ value: LegacyVideoRoomCreatedRsp) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomCreatedRsp.lower(value)
}


public struct LegacyVideoRoomKickParams {
    public let room: JanusId
    public let id: JanusId
    public let secret: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId, id: JanusId, secret: String?) {
        self.room = room
        self.id = id
        self.secret = secret
    }
}

#if compiler(>=6)
extension LegacyVideoRoomKickParams: Sendable {}
#endif


extension LegacyVideoRoomKickParams: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomKickParams, rhs: LegacyVideoRoomKickParams) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(id)
        hasher.combine(secret)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomKickParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomKickParams {
        return
            try LegacyVideoRoomKickParams(
                room: FfiConverterTypeJanusId.read(from: &buf), 
                id: FfiConverterTypeJanusId.read(from: &buf), 
                secret: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomKickParams, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterTypeJanusId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.secret, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomKickParams_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomKickParams {
    return try FfiConverterTypeLegacyVideoRoomKickParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomKickParams_lower(_ value: LegacyVideoRoomKickParams) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomKickParams.lower(value)
}


public struct LegacyVideoRoomPublisher {
    public let id: JanusId
    public let display: String?
    public let substream: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: JanusId, display: String?, substream: UInt8?) {
        self.id = id
        self.display = display
        self.substream = substream
    }
}

#if compiler(>=6)
extension LegacyVideoRoomPublisher: Sendable {}
#endif


extension LegacyVideoRoomPublisher: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomPublisher, rhs: LegacyVideoRoomPublisher) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.substream != rhs.substream {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(display)
        hasher.combine(substream)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomPublisher: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomPublisher {
        return
            try LegacyVideoRoomPublisher(
                id: FfiConverterTypeJanusId.read(from: &buf), 
                display: FfiConverterOptionString.read(from: &buf), 
                substream: FfiConverterOptionUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomPublisher, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.display, into: &buf)
        FfiConverterOptionUInt8.write(value.substream, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomPublisher_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomPublisher {
    return try FfiConverterTypeLegacyVideoRoomPublisher.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomPublisher_lower(_ value: LegacyVideoRoomPublisher) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomPublisher.lower(value)
}


public struct LegacyVideoRoomPublisherConfigureParams {
    public let audio: Bool?
    public let video: Bool?
    public let data: Bool?
    public let bitrate: UInt64?
    public let keyframe: Bool?
    public let record: Bool?
    public let filename: String?
    public let display: String?
    public let audioActivePackets: UInt64?
    public let audioLevelAverage: UInt64?
    public let minDelay: UInt64?
    public let maxDelay: UInt64?
    public let videocodec: LegacyVideoRoomVideoCodec?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(audio: Bool? = nil, video: Bool? = nil, data: Bool? = nil, bitrate: UInt64? = nil, keyframe: Bool? = nil, record: Bool? = nil, filename: String? = nil, display: String? = nil, audioActivePackets: UInt64? = nil, audioLevelAverage: UInt64? = nil, minDelay: UInt64? = nil, maxDelay: UInt64? = nil, videocodec: LegacyVideoRoomVideoCodec? = nil) {
        self.audio = audio
        self.video = video
        self.data = data
        self.bitrate = bitrate
        self.keyframe = keyframe
        self.record = record
        self.filename = filename
        self.display = display
        self.audioActivePackets = audioActivePackets
        self.audioLevelAverage = audioLevelAverage
        self.minDelay = minDelay
        self.maxDelay = maxDelay
        self.videocodec = videocodec
    }
}

#if compiler(>=6)
extension LegacyVideoRoomPublisherConfigureParams: Sendable {}
#endif


extension LegacyVideoRoomPublisherConfigureParams: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomPublisherConfigureParams, rhs: LegacyVideoRoomPublisherConfigureParams) -> Bool {
        if lhs.audio != rhs.audio {
            return false
        }
        if lhs.video != rhs.video {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.bitrate != rhs.bitrate {
            return false
        }
        if lhs.keyframe != rhs.keyframe {
            return false
        }
        if lhs.record != rhs.record {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.audioActivePackets != rhs.audioActivePackets {
            return false
        }
        if lhs.audioLevelAverage != rhs.audioLevelAverage {
            return false
        }
        if lhs.minDelay != rhs.minDelay {
            return false
        }
        if lhs.maxDelay != rhs.maxDelay {
            return false
        }
        if lhs.videocodec != rhs.videocodec {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(audio)
        hasher.combine(video)
        hasher.combine(data)
        hasher.combine(bitrate)
        hasher.combine(keyframe)
        hasher.combine(record)
        hasher.combine(filename)
        hasher.combine(display)
        hasher.combine(audioActivePackets)
        hasher.combine(audioLevelAverage)
        hasher.combine(minDelay)
        hasher.combine(maxDelay)
        hasher.combine(videocodec)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomPublisherConfigureParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomPublisherConfigureParams {
        return
            try LegacyVideoRoomPublisherConfigureParams(
                audio: FfiConverterOptionBool.read(from: &buf), 
                video: FfiConverterOptionBool.read(from: &buf), 
                data: FfiConverterOptionBool.read(from: &buf), 
                bitrate: FfiConverterOptionUInt64.read(from: &buf), 
                keyframe: FfiConverterOptionBool.read(from: &buf), 
                record: FfiConverterOptionBool.read(from: &buf), 
                filename: FfiConverterOptionString.read(from: &buf), 
                display: FfiConverterOptionString.read(from: &buf), 
                audioActivePackets: FfiConverterOptionUInt64.read(from: &buf), 
                audioLevelAverage: FfiConverterOptionUInt64.read(from: &buf), 
                minDelay: FfiConverterOptionUInt64.read(from: &buf), 
                maxDelay: FfiConverterOptionUInt64.read(from: &buf), 
                videocodec: FfiConverterOptionTypeLegacyVideoRoomVideoCodec.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomPublisherConfigureParams, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.audio, into: &buf)
        FfiConverterOptionBool.write(value.video, into: &buf)
        FfiConverterOptionBool.write(value.data, into: &buf)
        FfiConverterOptionUInt64.write(value.bitrate, into: &buf)
        FfiConverterOptionBool.write(value.keyframe, into: &buf)
        FfiConverterOptionBool.write(value.record, into: &buf)
        FfiConverterOptionString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.display, into: &buf)
        FfiConverterOptionUInt64.write(value.audioActivePackets, into: &buf)
        FfiConverterOptionUInt64.write(value.audioLevelAverage, into: &buf)
        FfiConverterOptionUInt64.write(value.minDelay, into: &buf)
        FfiConverterOptionUInt64.write(value.maxDelay, into: &buf)
        FfiConverterOptionTypeLegacyVideoRoomVideoCodec.write(value.videocodec, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomPublisherConfigureParams_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomPublisherConfigureParams {
    return try FfiConverterTypeLegacyVideoRoomPublisherConfigureParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomPublisherConfigureParams_lower(_ value: LegacyVideoRoomPublisherConfigureParams) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomPublisherConfigureParams.lower(value)
}


public struct LegacyVideoRoomPublisherJoinAndConfigureParams {
    public let joinParams: LegacyVideoRoomPublisherJoinParams
    public let configureParams: LegacyVideoRoomPublisherConfigureParams

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(joinParams: LegacyVideoRoomPublisherJoinParams, configureParams: LegacyVideoRoomPublisherConfigureParams) {
        self.joinParams = joinParams
        self.configureParams = configureParams
    }
}

#if compiler(>=6)
extension LegacyVideoRoomPublisherJoinAndConfigureParams: Sendable {}
#endif


extension LegacyVideoRoomPublisherJoinAndConfigureParams: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomPublisherJoinAndConfigureParams, rhs: LegacyVideoRoomPublisherJoinAndConfigureParams) -> Bool {
        if lhs.joinParams != rhs.joinParams {
            return false
        }
        if lhs.configureParams != rhs.configureParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(joinParams)
        hasher.combine(configureParams)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomPublisherJoinAndConfigureParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomPublisherJoinAndConfigureParams {
        return
            try LegacyVideoRoomPublisherJoinAndConfigureParams(
                joinParams: FfiConverterTypeLegacyVideoRoomPublisherJoinParams.read(from: &buf), 
                configureParams: FfiConverterTypeLegacyVideoRoomPublisherConfigureParams.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomPublisherJoinAndConfigureParams, into buf: inout [UInt8]) {
        FfiConverterTypeLegacyVideoRoomPublisherJoinParams.write(value.joinParams, into: &buf)
        FfiConverterTypeLegacyVideoRoomPublisherConfigureParams.write(value.configureParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomPublisherJoinAndConfigureParams_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomPublisherJoinAndConfigureParams {
    return try FfiConverterTypeLegacyVideoRoomPublisherJoinAndConfigureParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomPublisherJoinAndConfigureParams_lower(_ value: LegacyVideoRoomPublisherJoinAndConfigureParams) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomPublisherJoinAndConfigureParams.lower(value)
}


public struct LegacyVideoRoomPublisherJoinParams {
    public let room: JanusId
    public let optional: LegacyVideoRoomPublisherJoinParamsOptional

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId, optional: LegacyVideoRoomPublisherJoinParamsOptional) {
        self.room = room
        self.optional = optional
    }
}

#if compiler(>=6)
extension LegacyVideoRoomPublisherJoinParams: Sendable {}
#endif


extension LegacyVideoRoomPublisherJoinParams: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomPublisherJoinParams, rhs: LegacyVideoRoomPublisherJoinParams) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.optional != rhs.optional {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(optional)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomPublisherJoinParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomPublisherJoinParams {
        return
            try LegacyVideoRoomPublisherJoinParams(
                room: FfiConverterTypeJanusId.read(from: &buf), 
                optional: FfiConverterTypeLegacyVideoRoomPublisherJoinParamsOptional.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomPublisherJoinParams, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterTypeLegacyVideoRoomPublisherJoinParamsOptional.write(value.optional, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomPublisherJoinParams_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomPublisherJoinParams {
    return try FfiConverterTypeLegacyVideoRoomPublisherJoinParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomPublisherJoinParams_lower(_ value: LegacyVideoRoomPublisherJoinParams) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomPublisherJoinParams.lower(value)
}


public struct LegacyVideoRoomPublisherJoinParamsOptional {
    public let id: JanusId?
    public let display: String?
    public let token: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: JanusId? = nil, display: String? = nil, token: String? = nil) {
        self.id = id
        self.display = display
        self.token = token
    }
}

#if compiler(>=6)
extension LegacyVideoRoomPublisherJoinParamsOptional: Sendable {}
#endif


extension LegacyVideoRoomPublisherJoinParamsOptional: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomPublisherJoinParamsOptional, rhs: LegacyVideoRoomPublisherJoinParamsOptional) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(display)
        hasher.combine(token)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomPublisherJoinParamsOptional: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomPublisherJoinParamsOptional {
        return
            try LegacyVideoRoomPublisherJoinParamsOptional(
                id: FfiConverterOptionTypeJanusId.read(from: &buf), 
                display: FfiConverterOptionString.read(from: &buf), 
                token: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomPublisherJoinParamsOptional, into buf: inout [UInt8]) {
        FfiConverterOptionTypeJanusId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.display, into: &buf)
        FfiConverterOptionString.write(value.token, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomPublisherJoinParamsOptional_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomPublisherJoinParamsOptional {
    return try FfiConverterTypeLegacyVideoRoomPublisherJoinParamsOptional.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomPublisherJoinParamsOptional_lower(_ value: LegacyVideoRoomPublisherJoinParamsOptional) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomPublisherJoinParamsOptional.lower(value)
}


public struct LegacyVideoRoomSubscriberConfigureParams {
    public let audio: Bool?
    public let video: Bool?
    public let data: Bool?
    public let substream: UInt8?
    public let temporal: UInt8?
    public let fallback: UInt64?
    public let spatialLayer: UInt8?
    public let temporalLayer: UInt8?
    public let audioLevelAverage: UInt64?
    public let audioActivePackets: UInt64?
    public let minDelay: UInt64?
    public let maxDelay: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(audio: Bool? = nil, video: Bool? = nil, data: Bool? = nil, substream: UInt8? = nil, temporal: UInt8? = nil, fallback: UInt64? = nil, spatialLayer: UInt8? = nil, temporalLayer: UInt8? = nil, audioLevelAverage: UInt64? = nil, audioActivePackets: UInt64? = nil, minDelay: UInt64? = nil, maxDelay: UInt64? = nil) {
        self.audio = audio
        self.video = video
        self.data = data
        self.substream = substream
        self.temporal = temporal
        self.fallback = fallback
        self.spatialLayer = spatialLayer
        self.temporalLayer = temporalLayer
        self.audioLevelAverage = audioLevelAverage
        self.audioActivePackets = audioActivePackets
        self.minDelay = minDelay
        self.maxDelay = maxDelay
    }
}

#if compiler(>=6)
extension LegacyVideoRoomSubscriberConfigureParams: Sendable {}
#endif


extension LegacyVideoRoomSubscriberConfigureParams: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomSubscriberConfigureParams, rhs: LegacyVideoRoomSubscriberConfigureParams) -> Bool {
        if lhs.audio != rhs.audio {
            return false
        }
        if lhs.video != rhs.video {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.substream != rhs.substream {
            return false
        }
        if lhs.temporal != rhs.temporal {
            return false
        }
        if lhs.fallback != rhs.fallback {
            return false
        }
        if lhs.spatialLayer != rhs.spatialLayer {
            return false
        }
        if lhs.temporalLayer != rhs.temporalLayer {
            return false
        }
        if lhs.audioLevelAverage != rhs.audioLevelAverage {
            return false
        }
        if lhs.audioActivePackets != rhs.audioActivePackets {
            return false
        }
        if lhs.minDelay != rhs.minDelay {
            return false
        }
        if lhs.maxDelay != rhs.maxDelay {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(audio)
        hasher.combine(video)
        hasher.combine(data)
        hasher.combine(substream)
        hasher.combine(temporal)
        hasher.combine(fallback)
        hasher.combine(spatialLayer)
        hasher.combine(temporalLayer)
        hasher.combine(audioLevelAverage)
        hasher.combine(audioActivePackets)
        hasher.combine(minDelay)
        hasher.combine(maxDelay)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomSubscriberConfigureParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomSubscriberConfigureParams {
        return
            try LegacyVideoRoomSubscriberConfigureParams(
                audio: FfiConverterOptionBool.read(from: &buf), 
                video: FfiConverterOptionBool.read(from: &buf), 
                data: FfiConverterOptionBool.read(from: &buf), 
                substream: FfiConverterOptionUInt8.read(from: &buf), 
                temporal: FfiConverterOptionUInt8.read(from: &buf), 
                fallback: FfiConverterOptionUInt64.read(from: &buf), 
                spatialLayer: FfiConverterOptionUInt8.read(from: &buf), 
                temporalLayer: FfiConverterOptionUInt8.read(from: &buf), 
                audioLevelAverage: FfiConverterOptionUInt64.read(from: &buf), 
                audioActivePackets: FfiConverterOptionUInt64.read(from: &buf), 
                minDelay: FfiConverterOptionUInt64.read(from: &buf), 
                maxDelay: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomSubscriberConfigureParams, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.audio, into: &buf)
        FfiConverterOptionBool.write(value.video, into: &buf)
        FfiConverterOptionBool.write(value.data, into: &buf)
        FfiConverterOptionUInt8.write(value.substream, into: &buf)
        FfiConverterOptionUInt8.write(value.temporal, into: &buf)
        FfiConverterOptionUInt64.write(value.fallback, into: &buf)
        FfiConverterOptionUInt8.write(value.spatialLayer, into: &buf)
        FfiConverterOptionUInt8.write(value.temporalLayer, into: &buf)
        FfiConverterOptionUInt64.write(value.audioLevelAverage, into: &buf)
        FfiConverterOptionUInt64.write(value.audioActivePackets, into: &buf)
        FfiConverterOptionUInt64.write(value.minDelay, into: &buf)
        FfiConverterOptionUInt64.write(value.maxDelay, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomSubscriberConfigureParams_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomSubscriberConfigureParams {
    return try FfiConverterTypeLegacyVideoRoomSubscriberConfigureParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomSubscriberConfigureParams_lower(_ value: LegacyVideoRoomSubscriberConfigureParams) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomSubscriberConfigureParams.lower(value)
}


public struct LegacyVideoRoomSubscriberJoinParams {
    public let required: LegacyVideoRoomSubscriberJoinParamsRequired
    public let optional: LegacyVideoRoomSubscriberJoinParamsOptional

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(required: LegacyVideoRoomSubscriberJoinParamsRequired, optional: LegacyVideoRoomSubscriberJoinParamsOptional) {
        self.required = required
        self.optional = optional
    }
}

#if compiler(>=6)
extension LegacyVideoRoomSubscriberJoinParams: Sendable {}
#endif


extension LegacyVideoRoomSubscriberJoinParams: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomSubscriberJoinParams, rhs: LegacyVideoRoomSubscriberJoinParams) -> Bool {
        if lhs.required != rhs.required {
            return false
        }
        if lhs.optional != rhs.optional {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(required)
        hasher.combine(optional)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomSubscriberJoinParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomSubscriberJoinParams {
        return
            try LegacyVideoRoomSubscriberJoinParams(
                required: FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsRequired.read(from: &buf), 
                optional: FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsOptional.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomSubscriberJoinParams, into buf: inout [UInt8]) {
        FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsRequired.write(value.required, into: &buf)
        FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsOptional.write(value.optional, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomSubscriberJoinParams_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomSubscriberJoinParams {
    return try FfiConverterTypeLegacyVideoRoomSubscriberJoinParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomSubscriberJoinParams_lower(_ value: LegacyVideoRoomSubscriberJoinParams) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomSubscriberJoinParams.lower(value)
}


public struct LegacyVideoRoomSubscriberJoinParamsOptional {
    public let privateId: UInt64?
    public let closePc: Bool?
    public let audio: Bool?
    public let video: Bool?
    public let data: Bool?
    public let offerAudio: Bool?
    public let offerVideo: Bool?
    public let offerData: Bool?
    public let substream: UInt8?
    public let temporal: UInt8?
    public let fallback: UInt64?
    public let spatialLayer: UInt8?
    public let temporalLayer: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(privateId: UInt64? = nil, closePc: Bool? = nil, audio: Bool? = nil, video: Bool? = nil, data: Bool? = nil, offerAudio: Bool? = nil, offerVideo: Bool? = nil, offerData: Bool? = nil, substream: UInt8? = nil, temporal: UInt8? = nil, fallback: UInt64? = nil, spatialLayer: UInt8? = nil, temporalLayer: UInt8? = nil) {
        self.privateId = privateId
        self.closePc = closePc
        self.audio = audio
        self.video = video
        self.data = data
        self.offerAudio = offerAudio
        self.offerVideo = offerVideo
        self.offerData = offerData
        self.substream = substream
        self.temporal = temporal
        self.fallback = fallback
        self.spatialLayer = spatialLayer
        self.temporalLayer = temporalLayer
    }
}

#if compiler(>=6)
extension LegacyVideoRoomSubscriberJoinParamsOptional: Sendable {}
#endif


extension LegacyVideoRoomSubscriberJoinParamsOptional: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomSubscriberJoinParamsOptional, rhs: LegacyVideoRoomSubscriberJoinParamsOptional) -> Bool {
        if lhs.privateId != rhs.privateId {
            return false
        }
        if lhs.closePc != rhs.closePc {
            return false
        }
        if lhs.audio != rhs.audio {
            return false
        }
        if lhs.video != rhs.video {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.offerAudio != rhs.offerAudio {
            return false
        }
        if lhs.offerVideo != rhs.offerVideo {
            return false
        }
        if lhs.offerData != rhs.offerData {
            return false
        }
        if lhs.substream != rhs.substream {
            return false
        }
        if lhs.temporal != rhs.temporal {
            return false
        }
        if lhs.fallback != rhs.fallback {
            return false
        }
        if lhs.spatialLayer != rhs.spatialLayer {
            return false
        }
        if lhs.temporalLayer != rhs.temporalLayer {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(privateId)
        hasher.combine(closePc)
        hasher.combine(audio)
        hasher.combine(video)
        hasher.combine(data)
        hasher.combine(offerAudio)
        hasher.combine(offerVideo)
        hasher.combine(offerData)
        hasher.combine(substream)
        hasher.combine(temporal)
        hasher.combine(fallback)
        hasher.combine(spatialLayer)
        hasher.combine(temporalLayer)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsOptional: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomSubscriberJoinParamsOptional {
        return
            try LegacyVideoRoomSubscriberJoinParamsOptional(
                privateId: FfiConverterOptionUInt64.read(from: &buf), 
                closePc: FfiConverterOptionBool.read(from: &buf), 
                audio: FfiConverterOptionBool.read(from: &buf), 
                video: FfiConverterOptionBool.read(from: &buf), 
                data: FfiConverterOptionBool.read(from: &buf), 
                offerAudio: FfiConverterOptionBool.read(from: &buf), 
                offerVideo: FfiConverterOptionBool.read(from: &buf), 
                offerData: FfiConverterOptionBool.read(from: &buf), 
                substream: FfiConverterOptionUInt8.read(from: &buf), 
                temporal: FfiConverterOptionUInt8.read(from: &buf), 
                fallback: FfiConverterOptionUInt64.read(from: &buf), 
                spatialLayer: FfiConverterOptionUInt8.read(from: &buf), 
                temporalLayer: FfiConverterOptionUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomSubscriberJoinParamsOptional, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.privateId, into: &buf)
        FfiConverterOptionBool.write(value.closePc, into: &buf)
        FfiConverterOptionBool.write(value.audio, into: &buf)
        FfiConverterOptionBool.write(value.video, into: &buf)
        FfiConverterOptionBool.write(value.data, into: &buf)
        FfiConverterOptionBool.write(value.offerAudio, into: &buf)
        FfiConverterOptionBool.write(value.offerVideo, into: &buf)
        FfiConverterOptionBool.write(value.offerData, into: &buf)
        FfiConverterOptionUInt8.write(value.substream, into: &buf)
        FfiConverterOptionUInt8.write(value.temporal, into: &buf)
        FfiConverterOptionUInt64.write(value.fallback, into: &buf)
        FfiConverterOptionUInt8.write(value.spatialLayer, into: &buf)
        FfiConverterOptionUInt8.write(value.temporalLayer, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsOptional_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomSubscriberJoinParamsOptional {
    return try FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsOptional.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsOptional_lower(_ value: LegacyVideoRoomSubscriberJoinParamsOptional) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsOptional.lower(value)
}


public struct LegacyVideoRoomSubscriberJoinParamsRequired {
    public let room: JanusId
    public let feed: JanusId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId, feed: JanusId) {
        self.room = room
        self.feed = feed
    }
}

#if compiler(>=6)
extension LegacyVideoRoomSubscriberJoinParamsRequired: Sendable {}
#endif


extension LegacyVideoRoomSubscriberJoinParamsRequired: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomSubscriberJoinParamsRequired, rhs: LegacyVideoRoomSubscriberJoinParamsRequired) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.feed != rhs.feed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(feed)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsRequired: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomSubscriberJoinParamsRequired {
        return
            try LegacyVideoRoomSubscriberJoinParamsRequired(
                room: FfiConverterTypeJanusId.read(from: &buf), 
                feed: FfiConverterTypeJanusId.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomSubscriberJoinParamsRequired, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterTypeJanusId.write(value.feed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsRequired_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomSubscriberJoinParamsRequired {
    return try FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsRequired.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsRequired_lower(_ value: LegacyVideoRoomSubscriberJoinParamsRequired) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomSubscriberJoinParamsRequired.lower(value)
}


public struct LegacyVideoRoomVideoCodecList {
    public let codecs: [LegacyVideoRoomVideoCodec]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(codecs: [LegacyVideoRoomVideoCodec]) {
        self.codecs = codecs
    }
}

#if compiler(>=6)
extension LegacyVideoRoomVideoCodecList: Sendable {}
#endif


extension LegacyVideoRoomVideoCodecList: Equatable, Hashable {
    public static func ==(lhs: LegacyVideoRoomVideoCodecList, rhs: LegacyVideoRoomVideoCodecList) -> Bool {
        if lhs.codecs != rhs.codecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(codecs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomVideoCodecList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomVideoCodecList {
        return
            try LegacyVideoRoomVideoCodecList(
                codecs: FfiConverterSequenceTypeLegacyVideoRoomVideoCodec.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyVideoRoomVideoCodecList, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeLegacyVideoRoomVideoCodec.write(value.codecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomVideoCodecList_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomVideoCodecList {
    return try FfiConverterTypeLegacyVideoRoomVideoCodecList.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomVideoCodecList_lower(_ value: LegacyVideoRoomVideoCodecList) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomVideoCodecList.lower(value)
}


public struct MetaData {
    public let name: String
    public let author: String
    public let description: String
    public let versionString: String
    public let version: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, author: String, description: String, versionString: String, version: UInt64) {
        self.name = name
        self.author = author
        self.description = description
        self.versionString = versionString
        self.version = version
    }
}

#if compiler(>=6)
extension MetaData: Sendable {}
#endif


extension MetaData: Equatable, Hashable {
    public static func ==(lhs: MetaData, rhs: MetaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.versionString != rhs.versionString {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(author)
        hasher.combine(description)
        hasher.combine(versionString)
        hasher.combine(version)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMetaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetaData {
        return
            try MetaData(
                name: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                versionString: FfiConverterString.read(from: &buf), 
                version: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: MetaData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.versionString, into: &buf)
        FfiConverterUInt64.write(value.version, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMetaData_lift(_ buf: RustBuffer) throws -> MetaData {
    return try FfiConverterTypeMetaData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMetaData_lower(_ value: MetaData) -> RustBuffer {
    return FfiConverterTypeMetaData.lower(value)
}


public struct Publisher {
    public let id: JanusId
    public let display: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: JanusId, display: String?) {
        self.id = id
        self.display = display
    }
}

#if compiler(>=6)
extension Publisher: Sendable {}
#endif


extension Publisher: Equatable, Hashable {
    public static func ==(lhs: Publisher, rhs: Publisher) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(display)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePublisher: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Publisher {
        return
            try Publisher(
                id: FfiConverterTypeJanusId.read(from: &buf), 
                display: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Publisher, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.display, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublisher_lift(_ buf: RustBuffer) throws -> Publisher {
    return try FfiConverterTypePublisher.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublisher_lower(_ value: Publisher) -> RustBuffer {
    return FfiConverterTypePublisher.lower(value)
}


public struct ServerInfoRsp {
    public let name: String
    public let version: UInt64
    public let versionString: String
    public let author: String
    public let commitHash: String
    public let compileTime: String
    public let logToStdout: Bool
    public let logToFile: Bool
    public let dataChannels: Bool
    public let acceptingNewSessions: Bool
    public let sessionTimeout: UInt64
    public let reclaimSessionTimeout: UInt64
    public let candidatesTimeout: UInt64
    public let serverName: String
    public let localIp: String
    public let ipv6: Bool
    public let iceLite: Bool
    public let iceTcp: Bool
    public let iceNomination: String
    public let iceKeepaliveConncheck: Bool
    public let fullTrickle: Bool
    public let mdnsEnabled: Bool
    public let minNackQueue: UInt64
    public let twccPeriod: UInt64
    public let dtlsMtu: UInt64
    public let staticEventLoops: UInt64
    public let apiSecret: Bool
    public let authToken: Bool
    public let eventHandlers: Bool
    public let opaqueidInApi: Bool
    public let dependencies: [String: String]
    public let transports: [String: MetaData]
    public let plugins: [String: MetaData]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, version: UInt64, versionString: String, author: String, commitHash: String, compileTime: String, logToStdout: Bool, logToFile: Bool, dataChannels: Bool, acceptingNewSessions: Bool, sessionTimeout: UInt64, reclaimSessionTimeout: UInt64, candidatesTimeout: UInt64, serverName: String, localIp: String, ipv6: Bool, iceLite: Bool, iceTcp: Bool, iceNomination: String, iceKeepaliveConncheck: Bool, fullTrickle: Bool, mdnsEnabled: Bool, minNackQueue: UInt64, twccPeriod: UInt64, dtlsMtu: UInt64, staticEventLoops: UInt64, apiSecret: Bool, authToken: Bool, eventHandlers: Bool, opaqueidInApi: Bool, dependencies: [String: String], transports: [String: MetaData], plugins: [String: MetaData]) {
        self.name = name
        self.version = version
        self.versionString = versionString
        self.author = author
        self.commitHash = commitHash
        self.compileTime = compileTime
        self.logToStdout = logToStdout
        self.logToFile = logToFile
        self.dataChannels = dataChannels
        self.acceptingNewSessions = acceptingNewSessions
        self.sessionTimeout = sessionTimeout
        self.reclaimSessionTimeout = reclaimSessionTimeout
        self.candidatesTimeout = candidatesTimeout
        self.serverName = serverName
        self.localIp = localIp
        self.ipv6 = ipv6
        self.iceLite = iceLite
        self.iceTcp = iceTcp
        self.iceNomination = iceNomination
        self.iceKeepaliveConncheck = iceKeepaliveConncheck
        self.fullTrickle = fullTrickle
        self.mdnsEnabled = mdnsEnabled
        self.minNackQueue = minNackQueue
        self.twccPeriod = twccPeriod
        self.dtlsMtu = dtlsMtu
        self.staticEventLoops = staticEventLoops
        self.apiSecret = apiSecret
        self.authToken = authToken
        self.eventHandlers = eventHandlers
        self.opaqueidInApi = opaqueidInApi
        self.dependencies = dependencies
        self.transports = transports
        self.plugins = plugins
    }
}

#if compiler(>=6)
extension ServerInfoRsp: Sendable {}
#endif


extension ServerInfoRsp: Equatable, Hashable {
    public static func ==(lhs: ServerInfoRsp, rhs: ServerInfoRsp) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.versionString != rhs.versionString {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.commitHash != rhs.commitHash {
            return false
        }
        if lhs.compileTime != rhs.compileTime {
            return false
        }
        if lhs.logToStdout != rhs.logToStdout {
            return false
        }
        if lhs.logToFile != rhs.logToFile {
            return false
        }
        if lhs.dataChannels != rhs.dataChannels {
            return false
        }
        if lhs.acceptingNewSessions != rhs.acceptingNewSessions {
            return false
        }
        if lhs.sessionTimeout != rhs.sessionTimeout {
            return false
        }
        if lhs.reclaimSessionTimeout != rhs.reclaimSessionTimeout {
            return false
        }
        if lhs.candidatesTimeout != rhs.candidatesTimeout {
            return false
        }
        if lhs.serverName != rhs.serverName {
            return false
        }
        if lhs.localIp != rhs.localIp {
            return false
        }
        if lhs.ipv6 != rhs.ipv6 {
            return false
        }
        if lhs.iceLite != rhs.iceLite {
            return false
        }
        if lhs.iceTcp != rhs.iceTcp {
            return false
        }
        if lhs.iceNomination != rhs.iceNomination {
            return false
        }
        if lhs.iceKeepaliveConncheck != rhs.iceKeepaliveConncheck {
            return false
        }
        if lhs.fullTrickle != rhs.fullTrickle {
            return false
        }
        if lhs.mdnsEnabled != rhs.mdnsEnabled {
            return false
        }
        if lhs.minNackQueue != rhs.minNackQueue {
            return false
        }
        if lhs.twccPeriod != rhs.twccPeriod {
            return false
        }
        if lhs.dtlsMtu != rhs.dtlsMtu {
            return false
        }
        if lhs.staticEventLoops != rhs.staticEventLoops {
            return false
        }
        if lhs.apiSecret != rhs.apiSecret {
            return false
        }
        if lhs.authToken != rhs.authToken {
            return false
        }
        if lhs.eventHandlers != rhs.eventHandlers {
            return false
        }
        if lhs.opaqueidInApi != rhs.opaqueidInApi {
            return false
        }
        if lhs.dependencies != rhs.dependencies {
            return false
        }
        if lhs.transports != rhs.transports {
            return false
        }
        if lhs.plugins != rhs.plugins {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(version)
        hasher.combine(versionString)
        hasher.combine(author)
        hasher.combine(commitHash)
        hasher.combine(compileTime)
        hasher.combine(logToStdout)
        hasher.combine(logToFile)
        hasher.combine(dataChannels)
        hasher.combine(acceptingNewSessions)
        hasher.combine(sessionTimeout)
        hasher.combine(reclaimSessionTimeout)
        hasher.combine(candidatesTimeout)
        hasher.combine(serverName)
        hasher.combine(localIp)
        hasher.combine(ipv6)
        hasher.combine(iceLite)
        hasher.combine(iceTcp)
        hasher.combine(iceNomination)
        hasher.combine(iceKeepaliveConncheck)
        hasher.combine(fullTrickle)
        hasher.combine(mdnsEnabled)
        hasher.combine(minNackQueue)
        hasher.combine(twccPeriod)
        hasher.combine(dtlsMtu)
        hasher.combine(staticEventLoops)
        hasher.combine(apiSecret)
        hasher.combine(authToken)
        hasher.combine(eventHandlers)
        hasher.combine(opaqueidInApi)
        hasher.combine(dependencies)
        hasher.combine(transports)
        hasher.combine(plugins)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeServerInfoRsp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServerInfoRsp {
        return
            try ServerInfoRsp(
                name: FfiConverterString.read(from: &buf), 
                version: FfiConverterUInt64.read(from: &buf), 
                versionString: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                commitHash: FfiConverterString.read(from: &buf), 
                compileTime: FfiConverterString.read(from: &buf), 
                logToStdout: FfiConverterBool.read(from: &buf), 
                logToFile: FfiConverterBool.read(from: &buf), 
                dataChannels: FfiConverterBool.read(from: &buf), 
                acceptingNewSessions: FfiConverterBool.read(from: &buf), 
                sessionTimeout: FfiConverterUInt64.read(from: &buf), 
                reclaimSessionTimeout: FfiConverterUInt64.read(from: &buf), 
                candidatesTimeout: FfiConverterUInt64.read(from: &buf), 
                serverName: FfiConverterString.read(from: &buf), 
                localIp: FfiConverterString.read(from: &buf), 
                ipv6: FfiConverterBool.read(from: &buf), 
                iceLite: FfiConverterBool.read(from: &buf), 
                iceTcp: FfiConverterBool.read(from: &buf), 
                iceNomination: FfiConverterString.read(from: &buf), 
                iceKeepaliveConncheck: FfiConverterBool.read(from: &buf), 
                fullTrickle: FfiConverterBool.read(from: &buf), 
                mdnsEnabled: FfiConverterBool.read(from: &buf), 
                minNackQueue: FfiConverterUInt64.read(from: &buf), 
                twccPeriod: FfiConverterUInt64.read(from: &buf), 
                dtlsMtu: FfiConverterUInt64.read(from: &buf), 
                staticEventLoops: FfiConverterUInt64.read(from: &buf), 
                apiSecret: FfiConverterBool.read(from: &buf), 
                authToken: FfiConverterBool.read(from: &buf), 
                eventHandlers: FfiConverterBool.read(from: &buf), 
                opaqueidInApi: FfiConverterBool.read(from: &buf), 
                dependencies: FfiConverterDictionaryStringString.read(from: &buf), 
                transports: FfiConverterDictionaryStringTypeMetaData.read(from: &buf), 
                plugins: FfiConverterDictionaryStringTypeMetaData.read(from: &buf)
        )
    }

    public static func write(_ value: ServerInfoRsp, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt64.write(value.version, into: &buf)
        FfiConverterString.write(value.versionString, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterString.write(value.commitHash, into: &buf)
        FfiConverterString.write(value.compileTime, into: &buf)
        FfiConverterBool.write(value.logToStdout, into: &buf)
        FfiConverterBool.write(value.logToFile, into: &buf)
        FfiConverterBool.write(value.dataChannels, into: &buf)
        FfiConverterBool.write(value.acceptingNewSessions, into: &buf)
        FfiConverterUInt64.write(value.sessionTimeout, into: &buf)
        FfiConverterUInt64.write(value.reclaimSessionTimeout, into: &buf)
        FfiConverterUInt64.write(value.candidatesTimeout, into: &buf)
        FfiConverterString.write(value.serverName, into: &buf)
        FfiConverterString.write(value.localIp, into: &buf)
        FfiConverterBool.write(value.ipv6, into: &buf)
        FfiConverterBool.write(value.iceLite, into: &buf)
        FfiConverterBool.write(value.iceTcp, into: &buf)
        FfiConverterString.write(value.iceNomination, into: &buf)
        FfiConverterBool.write(value.iceKeepaliveConncheck, into: &buf)
        FfiConverterBool.write(value.fullTrickle, into: &buf)
        FfiConverterBool.write(value.mdnsEnabled, into: &buf)
        FfiConverterUInt64.write(value.minNackQueue, into: &buf)
        FfiConverterUInt64.write(value.twccPeriod, into: &buf)
        FfiConverterUInt64.write(value.dtlsMtu, into: &buf)
        FfiConverterUInt64.write(value.staticEventLoops, into: &buf)
        FfiConverterBool.write(value.apiSecret, into: &buf)
        FfiConverterBool.write(value.authToken, into: &buf)
        FfiConverterBool.write(value.eventHandlers, into: &buf)
        FfiConverterBool.write(value.opaqueidInApi, into: &buf)
        FfiConverterDictionaryStringString.write(value.dependencies, into: &buf)
        FfiConverterDictionaryStringTypeMetaData.write(value.transports, into: &buf)
        FfiConverterDictionaryStringTypeMetaData.write(value.plugins, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServerInfoRsp_lift(_ buf: RustBuffer) throws -> ServerInfoRsp {
    return try FfiConverterTypeServerInfoRsp.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServerInfoRsp_lower(_ value: ServerInfoRsp) -> RustBuffer {
    return FfiConverterTypeServerInfoRsp.lower(value)
}


public struct U63 {
    public let inner: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inner: UInt64) {
        self.inner = inner
    }
}

#if compiler(>=6)
extension U63: Sendable {}
#endif


extension U63: Equatable, Hashable {
    public static func ==(lhs: U63, rhs: U63) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeU63: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U63 {
        return
            try U63(
                inner: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: U63, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.inner, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU63_lift(_ buf: RustBuffer) throws -> U63 {
    return try FfiConverterTypeU63.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU63_lower(_ value: U63) -> RustBuffer {
    return FfiConverterTypeU63.lower(value)
}


public struct VideoRoomAudioCodecList {
    public let codecs: [VideoRoomAudioCodec]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(codecs: [VideoRoomAudioCodec]) {
        self.codecs = codecs
    }
}

#if compiler(>=6)
extension VideoRoomAudioCodecList: Sendable {}
#endif


extension VideoRoomAudioCodecList: Equatable, Hashable {
    public static func ==(lhs: VideoRoomAudioCodecList, rhs: VideoRoomAudioCodecList) -> Bool {
        if lhs.codecs != rhs.codecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(codecs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomAudioCodecList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomAudioCodecList {
        return
            try VideoRoomAudioCodecList(
                codecs: FfiConverterSequenceTypeVideoRoomAudioCodec.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomAudioCodecList, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeVideoRoomAudioCodec.write(value.codecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomAudioCodecList_lift(_ buf: RustBuffer) throws -> VideoRoomAudioCodecList {
    return try FfiConverterTypeVideoRoomAudioCodecList.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomAudioCodecList_lower(_ value: VideoRoomAudioCodecList) -> RustBuffer {
    return FfiConverterTypeVideoRoomAudioCodecList.lower(value)
}


public struct VideoRoomConfigurePublisherStream {
    public let mid: String
    public let optional: VideoRoomConfigurePublisherStreamOptional

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mid: String, optional: VideoRoomConfigurePublisherStreamOptional) {
        self.mid = mid
        self.optional = optional
    }
}

#if compiler(>=6)
extension VideoRoomConfigurePublisherStream: Sendable {}
#endif


extension VideoRoomConfigurePublisherStream: Equatable, Hashable {
    public static func ==(lhs: VideoRoomConfigurePublisherStream, rhs: VideoRoomConfigurePublisherStream) -> Bool {
        if lhs.mid != rhs.mid {
            return false
        }
        if lhs.optional != rhs.optional {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mid)
        hasher.combine(optional)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomConfigurePublisherStream: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomConfigurePublisherStream {
        return
            try VideoRoomConfigurePublisherStream(
                mid: FfiConverterString.read(from: &buf), 
                optional: FfiConverterTypeVideoRoomConfigurePublisherStreamOptional.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomConfigurePublisherStream, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mid, into: &buf)
        FfiConverterTypeVideoRoomConfigurePublisherStreamOptional.write(value.optional, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomConfigurePublisherStream_lift(_ buf: RustBuffer) throws -> VideoRoomConfigurePublisherStream {
    return try FfiConverterTypeVideoRoomConfigurePublisherStream.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomConfigurePublisherStream_lower(_ value: VideoRoomConfigurePublisherStream) -> RustBuffer {
    return FfiConverterTypeVideoRoomConfigurePublisherStream.lower(value)
}


public struct VideoRoomConfigurePublisherStreamOptional {
    public let keyframe: Bool?
    public let send: Bool?
    public let minDelay: UInt64?
    public let maxDelay: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keyframe: Bool? = nil, send: Bool? = nil, minDelay: UInt64? = nil, maxDelay: UInt64? = nil) {
        self.keyframe = keyframe
        self.send = send
        self.minDelay = minDelay
        self.maxDelay = maxDelay
    }
}

#if compiler(>=6)
extension VideoRoomConfigurePublisherStreamOptional: Sendable {}
#endif


extension VideoRoomConfigurePublisherStreamOptional: Equatable, Hashable {
    public static func ==(lhs: VideoRoomConfigurePublisherStreamOptional, rhs: VideoRoomConfigurePublisherStreamOptional) -> Bool {
        if lhs.keyframe != rhs.keyframe {
            return false
        }
        if lhs.send != rhs.send {
            return false
        }
        if lhs.minDelay != rhs.minDelay {
            return false
        }
        if lhs.maxDelay != rhs.maxDelay {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keyframe)
        hasher.combine(send)
        hasher.combine(minDelay)
        hasher.combine(maxDelay)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomConfigurePublisherStreamOptional: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomConfigurePublisherStreamOptional {
        return
            try VideoRoomConfigurePublisherStreamOptional(
                keyframe: FfiConverterOptionBool.read(from: &buf), 
                send: FfiConverterOptionBool.read(from: &buf), 
                minDelay: FfiConverterOptionUInt64.read(from: &buf), 
                maxDelay: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomConfigurePublisherStreamOptional, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.keyframe, into: &buf)
        FfiConverterOptionBool.write(value.send, into: &buf)
        FfiConverterOptionUInt64.write(value.minDelay, into: &buf)
        FfiConverterOptionUInt64.write(value.maxDelay, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomConfigurePublisherStreamOptional_lift(_ buf: RustBuffer) throws -> VideoRoomConfigurePublisherStreamOptional {
    return try FfiConverterTypeVideoRoomConfigurePublisherStreamOptional.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomConfigurePublisherStreamOptional_lower(_ value: VideoRoomConfigurePublisherStreamOptional) -> RustBuffer {
    return FfiConverterTypeVideoRoomConfigurePublisherStreamOptional.lower(value)
}


public struct VideoRoomCreateParams {
    public let adminKey: String?
    public let room: JanusId?
    public let description: String?
    public let isPrivate: Bool?
    public let allowed: [String]?
    public let secret: String?
    public let pin: String?
    public let requirePvtid: Bool?
    public let signedTokens: Bool?
    public let bitrate: UInt64?
    public let bitrateCap: Bool?
    public let firFreq: UInt64?
    public let publishers: UInt64?
    public let audiocodec: VideoRoomAudioCodecList?
    public let videocodec: VideoRoomVideoCodecList?
    public let vp9Profile: String?
    public let h264Profile: String?
    public let opusFec: Bool?
    public let opusDtx: Bool?
    public let audiolevelExt: Bool?
    public let audiolevelEvent: Bool?
    public let audioActivePackets: UInt64?
    public let audioLevelAverage: UInt64?
    public let videoorientExt: Bool?
    public let playoutdelayExt: Bool?
    public let transportWideCcExt: Bool?
    public let record: Bool?
    public let recordDir: String?
    public let lockRecord: Bool?
    public let permanent: Bool?
    public let notifyJoining: Bool?
    public let requireE2ee: Bool?
    public let dummyPublisher: Bool?
    public let dummyStreams: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(adminKey: String? = nil, room: JanusId? = nil, description: String? = nil, isPrivate: Bool? = nil, allowed: [String]? = nil, secret: String? = nil, pin: String? = nil, requirePvtid: Bool? = nil, signedTokens: Bool? = nil, bitrate: UInt64? = nil, bitrateCap: Bool? = nil, firFreq: UInt64? = nil, publishers: UInt64? = nil, audiocodec: VideoRoomAudioCodecList? = nil, videocodec: VideoRoomVideoCodecList? = nil, vp9Profile: String? = nil, h264Profile: String? = nil, opusFec: Bool? = nil, opusDtx: Bool? = nil, audiolevelExt: Bool? = nil, audiolevelEvent: Bool? = nil, audioActivePackets: UInt64? = nil, audioLevelAverage: UInt64? = nil, videoorientExt: Bool? = nil, playoutdelayExt: Bool? = nil, transportWideCcExt: Bool? = nil, record: Bool? = nil, recordDir: String? = nil, lockRecord: Bool? = nil, permanent: Bool? = nil, notifyJoining: Bool? = nil, requireE2ee: Bool? = nil, dummyPublisher: Bool? = nil, dummyStreams: Bool? = nil) {
        self.adminKey = adminKey
        self.room = room
        self.description = description
        self.isPrivate = isPrivate
        self.allowed = allowed
        self.secret = secret
        self.pin = pin
        self.requirePvtid = requirePvtid
        self.signedTokens = signedTokens
        self.bitrate = bitrate
        self.bitrateCap = bitrateCap
        self.firFreq = firFreq
        self.publishers = publishers
        self.audiocodec = audiocodec
        self.videocodec = videocodec
        self.vp9Profile = vp9Profile
        self.h264Profile = h264Profile
        self.opusFec = opusFec
        self.opusDtx = opusDtx
        self.audiolevelExt = audiolevelExt
        self.audiolevelEvent = audiolevelEvent
        self.audioActivePackets = audioActivePackets
        self.audioLevelAverage = audioLevelAverage
        self.videoorientExt = videoorientExt
        self.playoutdelayExt = playoutdelayExt
        self.transportWideCcExt = transportWideCcExt
        self.record = record
        self.recordDir = recordDir
        self.lockRecord = lockRecord
        self.permanent = permanent
        self.notifyJoining = notifyJoining
        self.requireE2ee = requireE2ee
        self.dummyPublisher = dummyPublisher
        self.dummyStreams = dummyStreams
    }
}

#if compiler(>=6)
extension VideoRoomCreateParams: Sendable {}
#endif


extension VideoRoomCreateParams: Equatable, Hashable {
    public static func ==(lhs: VideoRoomCreateParams, rhs: VideoRoomCreateParams) -> Bool {
        if lhs.adminKey != rhs.adminKey {
            return false
        }
        if lhs.room != rhs.room {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.isPrivate != rhs.isPrivate {
            return false
        }
        if lhs.allowed != rhs.allowed {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.pin != rhs.pin {
            return false
        }
        if lhs.requirePvtid != rhs.requirePvtid {
            return false
        }
        if lhs.signedTokens != rhs.signedTokens {
            return false
        }
        if lhs.bitrate != rhs.bitrate {
            return false
        }
        if lhs.bitrateCap != rhs.bitrateCap {
            return false
        }
        if lhs.firFreq != rhs.firFreq {
            return false
        }
        if lhs.publishers != rhs.publishers {
            return false
        }
        if lhs.audiocodec != rhs.audiocodec {
            return false
        }
        if lhs.videocodec != rhs.videocodec {
            return false
        }
        if lhs.vp9Profile != rhs.vp9Profile {
            return false
        }
        if lhs.h264Profile != rhs.h264Profile {
            return false
        }
        if lhs.opusFec != rhs.opusFec {
            return false
        }
        if lhs.opusDtx != rhs.opusDtx {
            return false
        }
        if lhs.audiolevelExt != rhs.audiolevelExt {
            return false
        }
        if lhs.audiolevelEvent != rhs.audiolevelEvent {
            return false
        }
        if lhs.audioActivePackets != rhs.audioActivePackets {
            return false
        }
        if lhs.audioLevelAverage != rhs.audioLevelAverage {
            return false
        }
        if lhs.videoorientExt != rhs.videoorientExt {
            return false
        }
        if lhs.playoutdelayExt != rhs.playoutdelayExt {
            return false
        }
        if lhs.transportWideCcExt != rhs.transportWideCcExt {
            return false
        }
        if lhs.record != rhs.record {
            return false
        }
        if lhs.recordDir != rhs.recordDir {
            return false
        }
        if lhs.lockRecord != rhs.lockRecord {
            return false
        }
        if lhs.permanent != rhs.permanent {
            return false
        }
        if lhs.notifyJoining != rhs.notifyJoining {
            return false
        }
        if lhs.requireE2ee != rhs.requireE2ee {
            return false
        }
        if lhs.dummyPublisher != rhs.dummyPublisher {
            return false
        }
        if lhs.dummyStreams != rhs.dummyStreams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(adminKey)
        hasher.combine(room)
        hasher.combine(description)
        hasher.combine(isPrivate)
        hasher.combine(allowed)
        hasher.combine(secret)
        hasher.combine(pin)
        hasher.combine(requirePvtid)
        hasher.combine(signedTokens)
        hasher.combine(bitrate)
        hasher.combine(bitrateCap)
        hasher.combine(firFreq)
        hasher.combine(publishers)
        hasher.combine(audiocodec)
        hasher.combine(videocodec)
        hasher.combine(vp9Profile)
        hasher.combine(h264Profile)
        hasher.combine(opusFec)
        hasher.combine(opusDtx)
        hasher.combine(audiolevelExt)
        hasher.combine(audiolevelEvent)
        hasher.combine(audioActivePackets)
        hasher.combine(audioLevelAverage)
        hasher.combine(videoorientExt)
        hasher.combine(playoutdelayExt)
        hasher.combine(transportWideCcExt)
        hasher.combine(record)
        hasher.combine(recordDir)
        hasher.combine(lockRecord)
        hasher.combine(permanent)
        hasher.combine(notifyJoining)
        hasher.combine(requireE2ee)
        hasher.combine(dummyPublisher)
        hasher.combine(dummyStreams)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomCreateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomCreateParams {
        return
            try VideoRoomCreateParams(
                adminKey: FfiConverterOptionString.read(from: &buf), 
                room: FfiConverterOptionTypeJanusId.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                isPrivate: FfiConverterOptionBool.read(from: &buf), 
                allowed: FfiConverterOptionSequenceString.read(from: &buf), 
                secret: FfiConverterOptionString.read(from: &buf), 
                pin: FfiConverterOptionString.read(from: &buf), 
                requirePvtid: FfiConverterOptionBool.read(from: &buf), 
                signedTokens: FfiConverterOptionBool.read(from: &buf), 
                bitrate: FfiConverterOptionUInt64.read(from: &buf), 
                bitrateCap: FfiConverterOptionBool.read(from: &buf), 
                firFreq: FfiConverterOptionUInt64.read(from: &buf), 
                publishers: FfiConverterOptionUInt64.read(from: &buf), 
                audiocodec: FfiConverterOptionTypeVideoRoomAudioCodecList.read(from: &buf), 
                videocodec: FfiConverterOptionTypeVideoRoomVideoCodecList.read(from: &buf), 
                vp9Profile: FfiConverterOptionString.read(from: &buf), 
                h264Profile: FfiConverterOptionString.read(from: &buf), 
                opusFec: FfiConverterOptionBool.read(from: &buf), 
                opusDtx: FfiConverterOptionBool.read(from: &buf), 
                audiolevelExt: FfiConverterOptionBool.read(from: &buf), 
                audiolevelEvent: FfiConverterOptionBool.read(from: &buf), 
                audioActivePackets: FfiConverterOptionUInt64.read(from: &buf), 
                audioLevelAverage: FfiConverterOptionUInt64.read(from: &buf), 
                videoorientExt: FfiConverterOptionBool.read(from: &buf), 
                playoutdelayExt: FfiConverterOptionBool.read(from: &buf), 
                transportWideCcExt: FfiConverterOptionBool.read(from: &buf), 
                record: FfiConverterOptionBool.read(from: &buf), 
                recordDir: FfiConverterOptionString.read(from: &buf), 
                lockRecord: FfiConverterOptionBool.read(from: &buf), 
                permanent: FfiConverterOptionBool.read(from: &buf), 
                notifyJoining: FfiConverterOptionBool.read(from: &buf), 
                requireE2ee: FfiConverterOptionBool.read(from: &buf), 
                dummyPublisher: FfiConverterOptionBool.read(from: &buf), 
                dummyStreams: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomCreateParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.adminKey, into: &buf)
        FfiConverterOptionTypeJanusId.write(value.room, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionBool.write(value.isPrivate, into: &buf)
        FfiConverterOptionSequenceString.write(value.allowed, into: &buf)
        FfiConverterOptionString.write(value.secret, into: &buf)
        FfiConverterOptionString.write(value.pin, into: &buf)
        FfiConverterOptionBool.write(value.requirePvtid, into: &buf)
        FfiConverterOptionBool.write(value.signedTokens, into: &buf)
        FfiConverterOptionUInt64.write(value.bitrate, into: &buf)
        FfiConverterOptionBool.write(value.bitrateCap, into: &buf)
        FfiConverterOptionUInt64.write(value.firFreq, into: &buf)
        FfiConverterOptionUInt64.write(value.publishers, into: &buf)
        FfiConverterOptionTypeVideoRoomAudioCodecList.write(value.audiocodec, into: &buf)
        FfiConverterOptionTypeVideoRoomVideoCodecList.write(value.videocodec, into: &buf)
        FfiConverterOptionString.write(value.vp9Profile, into: &buf)
        FfiConverterOptionString.write(value.h264Profile, into: &buf)
        FfiConverterOptionBool.write(value.opusFec, into: &buf)
        FfiConverterOptionBool.write(value.opusDtx, into: &buf)
        FfiConverterOptionBool.write(value.audiolevelExt, into: &buf)
        FfiConverterOptionBool.write(value.audiolevelEvent, into: &buf)
        FfiConverterOptionUInt64.write(value.audioActivePackets, into: &buf)
        FfiConverterOptionUInt64.write(value.audioLevelAverage, into: &buf)
        FfiConverterOptionBool.write(value.videoorientExt, into: &buf)
        FfiConverterOptionBool.write(value.playoutdelayExt, into: &buf)
        FfiConverterOptionBool.write(value.transportWideCcExt, into: &buf)
        FfiConverterOptionBool.write(value.record, into: &buf)
        FfiConverterOptionString.write(value.recordDir, into: &buf)
        FfiConverterOptionBool.write(value.lockRecord, into: &buf)
        FfiConverterOptionBool.write(value.permanent, into: &buf)
        FfiConverterOptionBool.write(value.notifyJoining, into: &buf)
        FfiConverterOptionBool.write(value.requireE2ee, into: &buf)
        FfiConverterOptionBool.write(value.dummyPublisher, into: &buf)
        FfiConverterOptionBool.write(value.dummyStreams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomCreateParams_lift(_ buf: RustBuffer) throws -> VideoRoomCreateParams {
    return try FfiConverterTypeVideoRoomCreateParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomCreateParams_lower(_ value: VideoRoomCreateParams) -> RustBuffer {
    return FfiConverterTypeVideoRoomCreateParams.lower(value)
}


public struct VideoRoomCreatedRsp {
    public let room: JanusId
    public let permanent: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId, permanent: Bool) {
        self.room = room
        self.permanent = permanent
    }
}

#if compiler(>=6)
extension VideoRoomCreatedRsp: Sendable {}
#endif


extension VideoRoomCreatedRsp: Equatable, Hashable {
    public static func ==(lhs: VideoRoomCreatedRsp, rhs: VideoRoomCreatedRsp) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.permanent != rhs.permanent {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(permanent)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomCreatedRsp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomCreatedRsp {
        return
            try VideoRoomCreatedRsp(
                room: FfiConverterTypeJanusId.read(from: &buf), 
                permanent: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomCreatedRsp, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterBool.write(value.permanent, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomCreatedRsp_lift(_ buf: RustBuffer) throws -> VideoRoomCreatedRsp {
    return try FfiConverterTypeVideoRoomCreatedRsp.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomCreatedRsp_lower(_ value: VideoRoomCreatedRsp) -> RustBuffer {
    return FfiConverterTypeVideoRoomCreatedRsp.lower(value)
}


public struct VideoRoomPublishDescriptionParams {
    public let mid: String
    public let description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mid: String, description: String) {
        self.mid = mid
        self.description = description
    }
}

#if compiler(>=6)
extension VideoRoomPublishDescriptionParams: Sendable {}
#endif


extension VideoRoomPublishDescriptionParams: Equatable, Hashable {
    public static func ==(lhs: VideoRoomPublishDescriptionParams, rhs: VideoRoomPublishDescriptionParams) -> Bool {
        if lhs.mid != rhs.mid {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mid)
        hasher.combine(description)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomPublishDescriptionParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomPublishDescriptionParams {
        return
            try VideoRoomPublishDescriptionParams(
                mid: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomPublishDescriptionParams, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mid, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomPublishDescriptionParams_lift(_ buf: RustBuffer) throws -> VideoRoomPublishDescriptionParams {
    return try FfiConverterTypeVideoRoomPublishDescriptionParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomPublishDescriptionParams_lower(_ value: VideoRoomPublishDescriptionParams) -> RustBuffer {
    return FfiConverterTypeVideoRoomPublishDescriptionParams.lower(value)
}


public struct VideoRoomPublisherConfigureParams {
    public let audio: Bool?
    public let video: Bool?
    public let bitrate: UInt64?
    public let keyframe: Bool?
    public let record: Bool?
    public let filename: String?
    public let display: String?
    public let audioActivePackets: UInt64?
    public let audioLevelAverage: UInt64?
    public let streams: [VideoRoomConfigurePublisherStream]?
    public let descriptions: [VideoRoomPublishDescriptionParams]?
    public let videocodec: VideoRoomVideoCodec?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(audio: Bool? = nil, video: Bool? = nil, bitrate: UInt64? = nil, keyframe: Bool? = nil, record: Bool? = nil, filename: String? = nil, display: String? = nil, audioActivePackets: UInt64? = nil, audioLevelAverage: UInt64? = nil, streams: [VideoRoomConfigurePublisherStream]? = nil, descriptions: [VideoRoomPublishDescriptionParams]? = nil, videocodec: VideoRoomVideoCodec? = nil) {
        self.audio = audio
        self.video = video
        self.bitrate = bitrate
        self.keyframe = keyframe
        self.record = record
        self.filename = filename
        self.display = display
        self.audioActivePackets = audioActivePackets
        self.audioLevelAverage = audioLevelAverage
        self.streams = streams
        self.descriptions = descriptions
        self.videocodec = videocodec
    }
}

#if compiler(>=6)
extension VideoRoomPublisherConfigureParams: Sendable {}
#endif


extension VideoRoomPublisherConfigureParams: Equatable, Hashable {
    public static func ==(lhs: VideoRoomPublisherConfigureParams, rhs: VideoRoomPublisherConfigureParams) -> Bool {
        if lhs.audio != rhs.audio {
            return false
        }
        if lhs.video != rhs.video {
            return false
        }
        if lhs.bitrate != rhs.bitrate {
            return false
        }
        if lhs.keyframe != rhs.keyframe {
            return false
        }
        if lhs.record != rhs.record {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.audioActivePackets != rhs.audioActivePackets {
            return false
        }
        if lhs.audioLevelAverage != rhs.audioLevelAverage {
            return false
        }
        if lhs.streams != rhs.streams {
            return false
        }
        if lhs.descriptions != rhs.descriptions {
            return false
        }
        if lhs.videocodec != rhs.videocodec {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(audio)
        hasher.combine(video)
        hasher.combine(bitrate)
        hasher.combine(keyframe)
        hasher.combine(record)
        hasher.combine(filename)
        hasher.combine(display)
        hasher.combine(audioActivePackets)
        hasher.combine(audioLevelAverage)
        hasher.combine(streams)
        hasher.combine(descriptions)
        hasher.combine(videocodec)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomPublisherConfigureParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomPublisherConfigureParams {
        return
            try VideoRoomPublisherConfigureParams(
                audio: FfiConverterOptionBool.read(from: &buf), 
                video: FfiConverterOptionBool.read(from: &buf), 
                bitrate: FfiConverterOptionUInt64.read(from: &buf), 
                keyframe: FfiConverterOptionBool.read(from: &buf), 
                record: FfiConverterOptionBool.read(from: &buf), 
                filename: FfiConverterOptionString.read(from: &buf), 
                display: FfiConverterOptionString.read(from: &buf), 
                audioActivePackets: FfiConverterOptionUInt64.read(from: &buf), 
                audioLevelAverage: FfiConverterOptionUInt64.read(from: &buf), 
                streams: FfiConverterOptionSequenceTypeVideoRoomConfigurePublisherStream.read(from: &buf), 
                descriptions: FfiConverterOptionSequenceTypeVideoRoomPublishDescriptionParams.read(from: &buf), 
                videocodec: FfiConverterOptionTypeVideoRoomVideoCodec.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomPublisherConfigureParams, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.audio, into: &buf)
        FfiConverterOptionBool.write(value.video, into: &buf)
        FfiConverterOptionUInt64.write(value.bitrate, into: &buf)
        FfiConverterOptionBool.write(value.keyframe, into: &buf)
        FfiConverterOptionBool.write(value.record, into: &buf)
        FfiConverterOptionString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.display, into: &buf)
        FfiConverterOptionUInt64.write(value.audioActivePackets, into: &buf)
        FfiConverterOptionUInt64.write(value.audioLevelAverage, into: &buf)
        FfiConverterOptionSequenceTypeVideoRoomConfigurePublisherStream.write(value.streams, into: &buf)
        FfiConverterOptionSequenceTypeVideoRoomPublishDescriptionParams.write(value.descriptions, into: &buf)
        FfiConverterOptionTypeVideoRoomVideoCodec.write(value.videocodec, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomPublisherConfigureParams_lift(_ buf: RustBuffer) throws -> VideoRoomPublisherConfigureParams {
    return try FfiConverterTypeVideoRoomPublisherConfigureParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomPublisherConfigureParams_lower(_ value: VideoRoomPublisherConfigureParams) -> RustBuffer {
    return FfiConverterTypeVideoRoomPublisherConfigureParams.lower(value)
}


public struct VideoRoomPublisherJoinAndConfigureParams {
    public let joinParams: VideoRoomPublisherJoinParams
    public let configureParams: VideoRoomPublisherConfigureParams

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(joinParams: VideoRoomPublisherJoinParams, configureParams: VideoRoomPublisherConfigureParams) {
        self.joinParams = joinParams
        self.configureParams = configureParams
    }
}

#if compiler(>=6)
extension VideoRoomPublisherJoinAndConfigureParams: Sendable {}
#endif


extension VideoRoomPublisherJoinAndConfigureParams: Equatable, Hashable {
    public static func ==(lhs: VideoRoomPublisherJoinAndConfigureParams, rhs: VideoRoomPublisherJoinAndConfigureParams) -> Bool {
        if lhs.joinParams != rhs.joinParams {
            return false
        }
        if lhs.configureParams != rhs.configureParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(joinParams)
        hasher.combine(configureParams)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomPublisherJoinAndConfigureParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomPublisherJoinAndConfigureParams {
        return
            try VideoRoomPublisherJoinAndConfigureParams(
                joinParams: FfiConverterTypeVideoRoomPublisherJoinParams.read(from: &buf), 
                configureParams: FfiConverterTypeVideoRoomPublisherConfigureParams.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomPublisherJoinAndConfigureParams, into buf: inout [UInt8]) {
        FfiConverterTypeVideoRoomPublisherJoinParams.write(value.joinParams, into: &buf)
        FfiConverterTypeVideoRoomPublisherConfigureParams.write(value.configureParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomPublisherJoinAndConfigureParams_lift(_ buf: RustBuffer) throws -> VideoRoomPublisherJoinAndConfigureParams {
    return try FfiConverterTypeVideoRoomPublisherJoinAndConfigureParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomPublisherJoinAndConfigureParams_lower(_ value: VideoRoomPublisherJoinAndConfigureParams) -> RustBuffer {
    return FfiConverterTypeVideoRoomPublisherJoinAndConfigureParams.lower(value)
}


public struct VideoRoomPublisherJoinParams {
    public let room: JanusId
    public let optional: VideoRoomPublisherJoinParamsOptional

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId, optional: VideoRoomPublisherJoinParamsOptional) {
        self.room = room
        self.optional = optional
    }
}

#if compiler(>=6)
extension VideoRoomPublisherJoinParams: Sendable {}
#endif


extension VideoRoomPublisherJoinParams: Equatable, Hashable {
    public static func ==(lhs: VideoRoomPublisherJoinParams, rhs: VideoRoomPublisherJoinParams) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.optional != rhs.optional {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(optional)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomPublisherJoinParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomPublisherJoinParams {
        return
            try VideoRoomPublisherJoinParams(
                room: FfiConverterTypeJanusId.read(from: &buf), 
                optional: FfiConverterTypeVideoRoomPublisherJoinParamsOptional.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomPublisherJoinParams, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterTypeVideoRoomPublisherJoinParamsOptional.write(value.optional, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomPublisherJoinParams_lift(_ buf: RustBuffer) throws -> VideoRoomPublisherJoinParams {
    return try FfiConverterTypeVideoRoomPublisherJoinParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomPublisherJoinParams_lower(_ value: VideoRoomPublisherJoinParams) -> RustBuffer {
    return FfiConverterTypeVideoRoomPublisherJoinParams.lower(value)
}


public struct VideoRoomPublisherJoinParamsOptional {
    public let id: JanusId?
    public let display: String?
    public let token: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: JanusId? = nil, display: String? = nil, token: String? = nil) {
        self.id = id
        self.display = display
        self.token = token
    }
}

#if compiler(>=6)
extension VideoRoomPublisherJoinParamsOptional: Sendable {}
#endif


extension VideoRoomPublisherJoinParamsOptional: Equatable, Hashable {
    public static func ==(lhs: VideoRoomPublisherJoinParamsOptional, rhs: VideoRoomPublisherJoinParamsOptional) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(display)
        hasher.combine(token)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomPublisherJoinParamsOptional: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomPublisherJoinParamsOptional {
        return
            try VideoRoomPublisherJoinParamsOptional(
                id: FfiConverterOptionTypeJanusId.read(from: &buf), 
                display: FfiConverterOptionString.read(from: &buf), 
                token: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomPublisherJoinParamsOptional, into buf: inout [UInt8]) {
        FfiConverterOptionTypeJanusId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.display, into: &buf)
        FfiConverterOptionString.write(value.token, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomPublisherJoinParamsOptional_lift(_ buf: RustBuffer) throws -> VideoRoomPublisherJoinParamsOptional {
    return try FfiConverterTypeVideoRoomPublisherJoinParamsOptional.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomPublisherJoinParamsOptional_lower(_ value: VideoRoomPublisherJoinParamsOptional) -> RustBuffer {
    return FfiConverterTypeVideoRoomPublisherJoinParamsOptional.lower(value)
}


public struct VideoRoomVideoCodecList {
    public let codecs: [VideoRoomVideoCodec]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(codecs: [VideoRoomVideoCodec]) {
        self.codecs = codecs
    }
}

#if compiler(>=6)
extension VideoRoomVideoCodecList: Sendable {}
#endif


extension VideoRoomVideoCodecList: Equatable, Hashable {
    public static func ==(lhs: VideoRoomVideoCodecList, rhs: VideoRoomVideoCodecList) -> Bool {
        if lhs.codecs != rhs.codecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(codecs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomVideoCodecList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomVideoCodecList {
        return
            try VideoRoomVideoCodecList(
                codecs: FfiConverterSequenceTypeVideoRoomVideoCodec.read(from: &buf)
        )
    }

    public static func write(_ value: VideoRoomVideoCodecList, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeVideoRoomVideoCodec.write(value.codecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomVideoCodecList_lift(_ buf: RustBuffer) throws -> VideoRoomVideoCodecList {
    return try FfiConverterTypeVideoRoomVideoCodecList.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomVideoCodecList_lower(_ value: VideoRoomVideoCodecList) -> RustBuffer {
    return FfiConverterTypeVideoRoomVideoCodecList.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AudioBridgeCodec {
    
    case opus
    /**
     * A-Law
     */
    case pcma
    /**
     * mu-Law
     */
    case pcmu
}


#if compiler(>=6)
extension AudioBridgeCodec: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeCodec: FfiConverterRustBuffer {
    typealias SwiftType = AudioBridgeCodec

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeCodec {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .opus
        
        case 2: return .pcma
        
        case 3: return .pcmu
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AudioBridgeCodec, into buf: inout [UInt8]) {
        switch value {
        
        
        case .opus:
            writeInt(&buf, Int32(1))
        
        
        case .pcma:
            writeInt(&buf, Int32(2))
        
        
        case .pcmu:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeCodec_lift(_ buf: RustBuffer) throws -> AudioBridgeCodec {
    return try FfiConverterTypeAudioBridgeCodec.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeCodec_lower(_ value: AudioBridgeCodec) -> RustBuffer {
    return FfiConverterTypeAudioBridgeCodec.lower(value)
}


extension AudioBridgeCodec: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GenericEvent {
    
    case detached
    /**
     * The PeerConnection was closed, either by Janus or by the user/application, and as such cannot be used anymore.
     */
    case hangup
    /**
     * Whether Janus is receiving (receiving: true/false) audio/video (type: "audio/video") on this PeerConnection.
     */
    case media
    case timeout
    /**
     * ICE and DTLS succeeded, and so Janus correctly established a PeerConnection with the user/application.
     */
    case webrtcUp
    /**
     * Whether Janus is reporting trouble sending/receiving (uplink: true/false) media on this PeerConnection.
     */
    case slowlink(uplink: Bool, media: String, lost: UInt32
    )
    case trickle
}


#if compiler(>=6)
extension GenericEvent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGenericEvent: FfiConverterRustBuffer {
    typealias SwiftType = GenericEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GenericEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .detached
        
        case 2: return .hangup
        
        case 3: return .media
        
        case 4: return .timeout
        
        case 5: return .webrtcUp
        
        case 6: return .slowlink(uplink: try FfiConverterBool.read(from: &buf), media: try FfiConverterString.read(from: &buf), lost: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 7: return .trickle
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GenericEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .detached:
            writeInt(&buf, Int32(1))
        
        
        case .hangup:
            writeInt(&buf, Int32(2))
        
        
        case .media:
            writeInt(&buf, Int32(3))
        
        
        case .timeout:
            writeInt(&buf, Int32(4))
        
        
        case .webrtcUp:
            writeInt(&buf, Int32(5))
        
        
        case let .slowlink(uplink,media,lost):
            writeInt(&buf, Int32(6))
            FfiConverterBool.write(uplink, into: &buf)
            FfiConverterString.write(media, into: &buf)
            FfiConverterUInt32.write(lost, into: &buf)
            
        
        case .trickle:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGenericEvent_lift(_ buf: RustBuffer) throws -> GenericEvent {
    return try FfiConverterTypeGenericEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGenericEvent_lower(_ value: GenericEvent) -> RustBuffer {
    return FfiConverterTypeGenericEvent.lower(value)
}


extension GenericEvent: Equatable, Hashable {}




public enum JanusGatewayCommunicationError: Swift.Error {

    
    
    case Serialize(body: String
    )
    case SendFailure(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJanusGatewayCommunicationError: FfiConverterRustBuffer {
    typealias SwiftType = JanusGatewayCommunicationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JanusGatewayCommunicationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Serialize(
            body: try FfiConverterString.read(from: &buf)
            )
        case 2: return .SendFailure(
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JanusGatewayCommunicationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Serialize(body):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(body, into: &buf)
            
        
        case let .SendFailure(reason):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayCommunicationError_lift(_ buf: RustBuffer) throws -> JanusGatewayCommunicationError {
    return try FfiConverterTypeJanusGatewayCommunicationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayCommunicationError_lower(_ value: JanusGatewayCommunicationError) -> RustBuffer {
    return FfiConverterTypeJanusGatewayCommunicationError.lower(value)
}


extension JanusGatewayCommunicationError: Equatable, Hashable {}



extension JanusGatewayCommunicationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum JanusGatewayConnectionError: Swift.Error {

    
    
    case ConnectionFailure(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJanusGatewayConnectionError: FfiConverterRustBuffer {
    typealias SwiftType = JanusGatewayConnectionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JanusGatewayConnectionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ConnectionFailure(
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JanusGatewayConnectionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ConnectionFailure(reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayConnectionError_lift(_ buf: RustBuffer) throws -> JanusGatewayConnectionError {
    return try FfiConverterTypeJanusGatewayConnectionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayConnectionError_lower(_ value: JanusGatewayConnectionError) -> RustBuffer {
    return FfiConverterTypeJanusGatewayConnectionError.lower(value)
}


extension JanusGatewayConnectionError: Equatable, Hashable {}



extension JanusGatewayConnectionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum JanusGatewayHandleError: Swift.Error {

    
    
    case HandleCreationFailure(plugin: String, reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJanusGatewayHandleError: FfiConverterRustBuffer {
    typealias SwiftType = JanusGatewayHandleError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JanusGatewayHandleError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .HandleCreationFailure(
            plugin: try FfiConverterString.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JanusGatewayHandleError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .HandleCreationFailure(plugin,reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(plugin, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayHandleError_lift(_ buf: RustBuffer) throws -> JanusGatewayHandleError {
    return try FfiConverterTypeJanusGatewayHandleError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayHandleError_lower(_ value: JanusGatewayHandleError) -> RustBuffer {
    return FfiConverterTypeJanusGatewayHandleError.lower(value)
}


extension JanusGatewayHandleError: Equatable, Hashable {}



extension JanusGatewayHandleError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum JanusGatewaySessionError: Swift.Error {

    
    
    case SessionCreationFailure(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJanusGatewaySessionError: FfiConverterRustBuffer {
    typealias SwiftType = JanusGatewaySessionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JanusGatewaySessionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SessionCreationFailure(
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JanusGatewaySessionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SessionCreationFailure(reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewaySessionError_lift(_ buf: RustBuffer) throws -> JanusGatewaySessionError {
    return try FfiConverterTypeJanusGatewaySessionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewaySessionError_lower(_ value: JanusGatewaySessionError) -> RustBuffer {
    return FfiConverterTypeJanusGatewaySessionError.lower(value)
}


extension JanusGatewaySessionError: Equatable, Hashable {}



extension JanusGatewaySessionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum JanusId {
    
    case string(String
    )
    case uint(U63
    )
}


#if compiler(>=6)
extension JanusId: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJanusId: FfiConverterRustBuffer {
    typealias SwiftType = JanusId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JanusId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .string(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .uint(try FfiConverterTypeU63.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JanusId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .string(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .uint(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeU63.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusId_lift(_ buf: RustBuffer) throws -> JanusId {
    return try FfiConverterTypeJanusId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusId_lower(_ value: JanusId) -> RustBuffer {
    return FfiConverterTypeJanusId.lower(value)
}


extension JanusId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum JsepType {
    
    case offer
    case answer
}


#if compiler(>=6)
extension JsepType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJsepType: FfiConverterRustBuffer {
    typealias SwiftType = JsepType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsepType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .offer
        
        case 2: return .answer
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsepType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .offer:
            writeInt(&buf, Int32(1))
        
        
        case .answer:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsepType_lift(_ buf: RustBuffer) throws -> JsepType {
    return try FfiConverterTypeJsepType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsepType_lower(_ value: JsepType) -> RustBuffer {
    return FfiConverterTypeJsepType.lower(value)
}


extension JsepType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LegacyVideoRoomAudioCodec {
    
    case opus
    case g722
    case pcmu
    case pcma
    case isac32
    case isac16
}


#if compiler(>=6)
extension LegacyVideoRoomAudioCodec: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomAudioCodec: FfiConverterRustBuffer {
    typealias SwiftType = LegacyVideoRoomAudioCodec

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomAudioCodec {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .opus
        
        case 2: return .g722
        
        case 3: return .pcmu
        
        case 4: return .pcma
        
        case 5: return .isac32
        
        case 6: return .isac16
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LegacyVideoRoomAudioCodec, into buf: inout [UInt8]) {
        switch value {
        
        
        case .opus:
            writeInt(&buf, Int32(1))
        
        
        case .g722:
            writeInt(&buf, Int32(2))
        
        
        case .pcmu:
            writeInt(&buf, Int32(3))
        
        
        case .pcma:
            writeInt(&buf, Int32(4))
        
        
        case .isac32:
            writeInt(&buf, Int32(5))
        
        
        case .isac16:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomAudioCodec_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomAudioCodec {
    return try FfiConverterTypeLegacyVideoRoomAudioCodec.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomAudioCodec_lower(_ value: LegacyVideoRoomAudioCodec) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomAudioCodec.lower(value)
}


extension LegacyVideoRoomAudioCodec: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LegacyVideoRoomVideoCodec {
    
    case vp8
    case vp9
    case h264
    case av1
    case h265
}


#if compiler(>=6)
extension LegacyVideoRoomVideoCodec: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyVideoRoomVideoCodec: FfiConverterRustBuffer {
    typealias SwiftType = LegacyVideoRoomVideoCodec

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyVideoRoomVideoCodec {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .vp8
        
        case 2: return .vp9
        
        case 3: return .h264
        
        case 4: return .av1
        
        case 5: return .h265
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LegacyVideoRoomVideoCodec, into buf: inout [UInt8]) {
        switch value {
        
        
        case .vp8:
            writeInt(&buf, Int32(1))
        
        
        case .vp9:
            writeInt(&buf, Int32(2))
        
        
        case .h264:
            writeInt(&buf, Int32(3))
        
        
        case .av1:
            writeInt(&buf, Int32(4))
        
        
        case .h265:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomVideoCodec_lift(_ buf: RustBuffer) throws -> LegacyVideoRoomVideoCodec {
    return try FfiConverterTypeLegacyVideoRoomVideoCodec.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyVideoRoomVideoCodec_lower(_ value: LegacyVideoRoomVideoCodec) -> RustBuffer {
    return FfiConverterTypeLegacyVideoRoomVideoCodec.lower(value)
}


extension LegacyVideoRoomVideoCodec: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VideoRoomAudioCodec {
    
    case opus
    case g722
    case pcmu
    case pcma
    case isac32
    case isac16
}


#if compiler(>=6)
extension VideoRoomAudioCodec: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomAudioCodec: FfiConverterRustBuffer {
    typealias SwiftType = VideoRoomAudioCodec

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomAudioCodec {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .opus
        
        case 2: return .g722
        
        case 3: return .pcmu
        
        case 4: return .pcma
        
        case 5: return .isac32
        
        case 6: return .isac16
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VideoRoomAudioCodec, into buf: inout [UInt8]) {
        switch value {
        
        
        case .opus:
            writeInt(&buf, Int32(1))
        
        
        case .g722:
            writeInt(&buf, Int32(2))
        
        
        case .pcmu:
            writeInt(&buf, Int32(3))
        
        
        case .pcma:
            writeInt(&buf, Int32(4))
        
        
        case .isac32:
            writeInt(&buf, Int32(5))
        
        
        case .isac16:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomAudioCodec_lift(_ buf: RustBuffer) throws -> VideoRoomAudioCodec {
    return try FfiConverterTypeVideoRoomAudioCodec.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomAudioCodec_lower(_ value: VideoRoomAudioCodec) -> RustBuffer {
    return FfiConverterTypeVideoRoomAudioCodec.lower(value)
}


extension VideoRoomAudioCodec: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VideoRoomVideoCodec {
    
    case vp8
    case vp9
    case h264
    case av1
    case h265
}


#if compiler(>=6)
extension VideoRoomVideoCodec: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoRoomVideoCodec: FfiConverterRustBuffer {
    typealias SwiftType = VideoRoomVideoCodec

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoRoomVideoCodec {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .vp8
        
        case 2: return .vp9
        
        case 3: return .h264
        
        case 4: return .av1
        
        case 5: return .h265
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VideoRoomVideoCodec, into buf: inout [UInt8]) {
        switch value {
        
        
        case .vp8:
            writeInt(&buf, Int32(1))
        
        
        case .vp9:
            writeInt(&buf, Int32(2))
        
        
        case .h264:
            writeInt(&buf, Int32(3))
        
        
        case .av1:
            writeInt(&buf, Int32(4))
        
        
        case .h265:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomVideoCodec_lift(_ buf: RustBuffer) throws -> VideoRoomVideoCodec {
    return try FfiConverterTypeVideoRoomVideoCodec.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoRoomVideoCodec_lower(_ value: VideoRoomVideoCodec) -> RustBuffer {
    return FfiConverterTypeVideoRoomVideoCodec.lower(value)
}


extension VideoRoomVideoCodec: Equatable, Hashable {}






public protocol AudioBridgeHandleCallback: AnyObject, Sendable {
    
    func onResult(transaction: String, result: String) 
    
    func onResultWithJsep(transaction: String, result: String, jsep: Jsep) 
    
    func onRoomJoinedWithJsep(id: JanusId, room: JanusId, participants: [AudioBridgeParticipant], jsep: Jsep) 
    
    func onRoomJoined(id: JanusId, room: JanusId, participants: [AudioBridgeParticipant]) 
    
    func onParticipantsJoined(room: JanusId, participants: [AudioBridgeParticipant]) 
    
    func onParticipantsUpdated(room: JanusId, participants: [AudioBridgeParticipant]) 
    
    func onParticipantLeft(room: JanusId, participantId: JanusId) 
    
    func onHandleEvent(event: GenericEvent) 
    
    func onAudioBridgeError(errorCode: UInt16, error: String) 
    
    func onOther(data: Data) 
    
}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAudioBridgeHandleCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceAudioBridgeHandleCallback] = [UniffiVTableCallbackInterfaceAudioBridgeHandleCallback(
        onResult: { (
            uniffiHandle: UInt64,
            transaction: RustBuffer,
            result: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onResult(
                     transaction: try FfiConverterString.lift(transaction),
                     result: try FfiConverterString.lift(result)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onResultWithJsep: { (
            uniffiHandle: UInt64,
            transaction: RustBuffer,
            result: RustBuffer,
            jsep: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onResultWithJsep(
                     transaction: try FfiConverterString.lift(transaction),
                     result: try FfiConverterString.lift(result),
                     jsep: try FfiConverterTypeJsep_lift(jsep)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onRoomJoinedWithJsep: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            room: RustBuffer,
            participants: RustBuffer,
            jsep: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onRoomJoinedWithJsep(
                     id: try FfiConverterTypeJanusId_lift(id),
                     room: try FfiConverterTypeJanusId_lift(room),
                     participants: try FfiConverterSequenceTypeAudioBridgeParticipant.lift(participants),
                     jsep: try FfiConverterTypeJsep_lift(jsep)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onRoomJoined: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            room: RustBuffer,
            participants: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onRoomJoined(
                     id: try FfiConverterTypeJanusId_lift(id),
                     room: try FfiConverterTypeJanusId_lift(room),
                     participants: try FfiConverterSequenceTypeAudioBridgeParticipant.lift(participants)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onParticipantsJoined: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            participants: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onParticipantsJoined(
                     room: try FfiConverterTypeJanusId_lift(room),
                     participants: try FfiConverterSequenceTypeAudioBridgeParticipant.lift(participants)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onParticipantsUpdated: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            participants: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onParticipantsUpdated(
                     room: try FfiConverterTypeJanusId_lift(room),
                     participants: try FfiConverterSequenceTypeAudioBridgeParticipant.lift(participants)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onParticipantLeft: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            participantId: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onParticipantLeft(
                     room: try FfiConverterTypeJanusId_lift(room),
                     participantId: try FfiConverterTypeJanusId_lift(participantId)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onHandleEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onHandleEvent(
                     event: try FfiConverterTypeGenericEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onAudioBridgeError: { (
            uniffiHandle: UInt64,
            errorCode: UInt16,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onAudioBridgeError(
                     errorCode: try FfiConverterUInt16.lift(errorCode),
                     error: try FfiConverterString.lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onOther: { (
            uniffiHandle: UInt64,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onOther(
                     data: try FfiConverterData.lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface AudioBridgeHandleCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitAudioBridgeHandleCallback() {
    uniffi_janus_gateway_fn_init_callback_vtable_audiobridgehandlecallback(UniffiCallbackInterfaceAudioBridgeHandleCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceAudioBridgeHandleCallback {
    fileprivate static let handleMap = UniffiHandleMap<AudioBridgeHandleCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceAudioBridgeHandleCallback : FfiConverter {
    typealias SwiftType = AudioBridgeHandleCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceAudioBridgeHandleCallback_lift(_ handle: UInt64) throws -> AudioBridgeHandleCallback {
    return try FfiConverterCallbackInterfaceAudioBridgeHandleCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceAudioBridgeHandleCallback_lower(_ v: AudioBridgeHandleCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceAudioBridgeHandleCallback.lower(v)
}




public protocol EchotestHandleCallback: AnyObject, Sendable {
    
    func onResult(echotest: String, result: String) 
    
    func onResultWithJsep(echotest: String, result: String, jsep: Jsep) 
    
    func onEchoTestError(errorCode: UInt16, error: String) 
    
    func onHandleEvent(event: GenericEvent) 
    
    func onOther(data: Data) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEchotestHandleCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceEchotestHandleCallback] = [UniffiVTableCallbackInterfaceEchotestHandleCallback(
        onResult: { (
            uniffiHandle: UInt64,
            echotest: RustBuffer,
            result: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onResult(
                     echotest: try FfiConverterString.lift(echotest),
                     result: try FfiConverterString.lift(result)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onResultWithJsep: { (
            uniffiHandle: UInt64,
            echotest: RustBuffer,
            result: RustBuffer,
            jsep: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onResultWithJsep(
                     echotest: try FfiConverterString.lift(echotest),
                     result: try FfiConverterString.lift(result),
                     jsep: try FfiConverterTypeJsep_lift(jsep)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onEchoTestError: { (
            uniffiHandle: UInt64,
            errorCode: UInt16,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onEchoTestError(
                     errorCode: try FfiConverterUInt16.lift(errorCode),
                     error: try FfiConverterString.lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onHandleEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onHandleEvent(
                     event: try FfiConverterTypeGenericEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onOther: { (
            uniffiHandle: UInt64,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onOther(
                     data: try FfiConverterData.lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EchotestHandleCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitEchotestHandleCallback() {
    uniffi_janus_gateway_fn_init_callback_vtable_echotesthandlecallback(UniffiCallbackInterfaceEchotestHandleCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceEchotestHandleCallback {
    fileprivate static let handleMap = UniffiHandleMap<EchotestHandleCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceEchotestHandleCallback : FfiConverter {
    typealias SwiftType = EchotestHandleCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceEchotestHandleCallback_lift(_ handle: UInt64) throws -> EchotestHandleCallback {
    return try FfiConverterCallbackInterfaceEchotestHandleCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceEchotestHandleCallback_lower(_ v: EchotestHandleCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceEchotestHandleCallback.lower(v)
}




public protocol HandleCallback: AnyObject, Sendable {
    
    func onPluginEvent(event: Data) 
    
    func onHandleEvent(event: GenericEvent) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceHandleCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceHandleCallback] = [UniffiVTableCallbackInterfaceHandleCallback(
        onPluginEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onPluginEvent(
                     event: try FfiConverterData.lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onHandleEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onHandleEvent(
                     event: try FfiConverterTypeGenericEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceHandleCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HandleCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitHandleCallback() {
    uniffi_janus_gateway_fn_init_callback_vtable_handlecallback(UniffiCallbackInterfaceHandleCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceHandleCallback {
    fileprivate static let handleMap = UniffiHandleMap<HandleCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceHandleCallback : FfiConverter {
    typealias SwiftType = HandleCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceHandleCallback_lift(_ handle: UInt64) throws -> HandleCallback {
    return try FfiConverterCallbackInterfaceHandleCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceHandleCallback_lower(_ v: HandleCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceHandleCallback.lower(v)
}




public protocol LegacyVideoRoomHandleCallback: AnyObject, Sendable {
    
    func onLegacyVideoRoomOther(data: Data) 
    
    func onLegacyVideoRoomHandleEvent(event: GenericEvent) 
    
    func onLegacyVideoRoomError(errorCode: UInt16, error: String) 
    
    func onLegacyVideoRoomJoined(id: JanusId, room: JanusId, description: String?, privateId: UInt64?, publishers: [LegacyVideoRoomPublisher], jsep: Jsep?) 
    
    func onLegacyVideoRoomConfigured(room: JanusId, jsep: Jsep?) 
    
    func onLegacyVideoRoomNewPublishers(room: JanusId, publishers: [LegacyVideoRoomPublisher]) 
    
    func onLegacyVideoRoomSubscriberAttached(id: JanusId, room: JanusId, display: String?, jsep: Jsep) 
    
    func onLegacyVideoRoomSlowLink() 
    
    func onLegacyVideoRoomUnpublished(room: JanusId, unpublished: JanusId) 
    
    func onLegacyVideoRoomSubscriberStarted(room: JanusId, started: String) 
    
    func onLegacyVideoRoomLeaving(room: JanusId, reason: String) 
    
    func onLegacyVideoRoomKicked(room: JanusId, participant: JanusId) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLegacyVideoRoomHandleCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLegacyVideoRoomHandleCallback] = [UniffiVTableCallbackInterfaceLegacyVideoRoomHandleCallback(
        onLegacyVideoRoomOther: { (
            uniffiHandle: UInt64,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomOther(
                     data: try FfiConverterData.lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomHandleEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomHandleEvent(
                     event: try FfiConverterTypeGenericEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomError: { (
            uniffiHandle: UInt64,
            errorCode: UInt16,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomError(
                     errorCode: try FfiConverterUInt16.lift(errorCode),
                     error: try FfiConverterString.lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomJoined: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            room: RustBuffer,
            description: RustBuffer,
            privateId: RustBuffer,
            publishers: RustBuffer,
            jsep: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomJoined(
                     id: try FfiConverterTypeJanusId_lift(id),
                     room: try FfiConverterTypeJanusId_lift(room),
                     description: try FfiConverterOptionString.lift(description),
                     privateId: try FfiConverterOptionUInt64.lift(privateId),
                     publishers: try FfiConverterSequenceTypeLegacyVideoRoomPublisher.lift(publishers),
                     jsep: try FfiConverterOptionTypeJsep.lift(jsep)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomConfigured: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            jsep: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomConfigured(
                     room: try FfiConverterTypeJanusId_lift(room),
                     jsep: try FfiConverterOptionTypeJsep.lift(jsep)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomNewPublishers: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            publishers: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomNewPublishers(
                     room: try FfiConverterTypeJanusId_lift(room),
                     publishers: try FfiConverterSequenceTypeLegacyVideoRoomPublisher.lift(publishers)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomSubscriberAttached: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            room: RustBuffer,
            display: RustBuffer,
            jsep: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomSubscriberAttached(
                     id: try FfiConverterTypeJanusId_lift(id),
                     room: try FfiConverterTypeJanusId_lift(room),
                     display: try FfiConverterOptionString.lift(display),
                     jsep: try FfiConverterTypeJsep_lift(jsep)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomSlowLink: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomSlowLink(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomUnpublished: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            unpublished: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomUnpublished(
                     room: try FfiConverterTypeJanusId_lift(room),
                     unpublished: try FfiConverterTypeJanusId_lift(unpublished)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomSubscriberStarted: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            started: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomSubscriberStarted(
                     room: try FfiConverterTypeJanusId_lift(room),
                     started: try FfiConverterString.lift(started)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomLeaving: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            reason: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomLeaving(
                     room: try FfiConverterTypeJanusId_lift(room),
                     reason: try FfiConverterString.lift(reason)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLegacyVideoRoomKicked: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            participant: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLegacyVideoRoomKicked(
                     room: try FfiConverterTypeJanusId_lift(room),
                     participant: try FfiConverterTypeJanusId_lift(participant)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LegacyVideoRoomHandleCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitLegacyVideoRoomHandleCallback() {
    uniffi_janus_gateway_fn_init_callback_vtable_legacyvideoroomhandlecallback(UniffiCallbackInterfaceLegacyVideoRoomHandleCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback {
    fileprivate static let handleMap = UniffiHandleMap<LegacyVideoRoomHandleCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback : FfiConverter {
    typealias SwiftType = LegacyVideoRoomHandleCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback_lift(_ handle: UInt64) throws -> LegacyVideoRoomHandleCallback {
    return try FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback_lower(_ v: LegacyVideoRoomHandleCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceLegacyVideoRoomHandleCallback.lower(v)
}




public protocol VideoRoomHandleCallback: AnyObject, Sendable {
    
    func onHandleEvent(event: GenericEvent) 
    
    func onVideoRoomError(errorCode: UInt16, error: String) 
    
    func onOther(data: Data) 
    
    func onConfigureWithJsep(room: JanusId, audioCodec: String?, videoCodec: String?, streams: [ConfiguredStream]?, jsep: Jsep) 
    
    func onRoomJoined(id: JanusId, room: JanusId, description: String?, privateId: UInt64, publishers: [Publisher]) 
    
    func onRoomJoinedWithJsep(id: JanusId, room: JanusId, description: String?, privateId: UInt64, publishers: [Publisher], jsep: Jsep) 
    
    func onKicked(room: JanusId, participant: JanusId) 
    
    func onLeaving(room: JanusId, reason: String) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceVideoRoomHandleCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceVideoRoomHandleCallback] = [UniffiVTableCallbackInterfaceVideoRoomHandleCallback(
        onHandleEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onHandleEvent(
                     event: try FfiConverterTypeGenericEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onVideoRoomError: { (
            uniffiHandle: UInt64,
            errorCode: UInt16,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onVideoRoomError(
                     errorCode: try FfiConverterUInt16.lift(errorCode),
                     error: try FfiConverterString.lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onOther: { (
            uniffiHandle: UInt64,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onOther(
                     data: try FfiConverterData.lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onConfigureWithJsep: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            audioCodec: RustBuffer,
            videoCodec: RustBuffer,
            streams: RustBuffer,
            jsep: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onConfigureWithJsep(
                     room: try FfiConverterTypeJanusId_lift(room),
                     audioCodec: try FfiConverterOptionString.lift(audioCodec),
                     videoCodec: try FfiConverterOptionString.lift(videoCodec),
                     streams: try FfiConverterOptionSequenceTypeConfiguredStream.lift(streams),
                     jsep: try FfiConverterTypeJsep_lift(jsep)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onRoomJoined: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            room: RustBuffer,
            description: RustBuffer,
            privateId: UInt64,
            publishers: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onRoomJoined(
                     id: try FfiConverterTypeJanusId_lift(id),
                     room: try FfiConverterTypeJanusId_lift(room),
                     description: try FfiConverterOptionString.lift(description),
                     privateId: try FfiConverterUInt64.lift(privateId),
                     publishers: try FfiConverterSequenceTypePublisher.lift(publishers)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onRoomJoinedWithJsep: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            room: RustBuffer,
            description: RustBuffer,
            privateId: UInt64,
            publishers: RustBuffer,
            jsep: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onRoomJoinedWithJsep(
                     id: try FfiConverterTypeJanusId_lift(id),
                     room: try FfiConverterTypeJanusId_lift(room),
                     description: try FfiConverterOptionString.lift(description),
                     privateId: try FfiConverterUInt64.lift(privateId),
                     publishers: try FfiConverterSequenceTypePublisher.lift(publishers),
                     jsep: try FfiConverterTypeJsep_lift(jsep)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onKicked: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            participant: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onKicked(
                     room: try FfiConverterTypeJanusId_lift(room),
                     participant: try FfiConverterTypeJanusId_lift(participant)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onLeaving: { (
            uniffiHandle: UInt64,
            room: RustBuffer,
            reason: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceVideoRoomHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLeaving(
                     room: try FfiConverterTypeJanusId_lift(room),
                     reason: try FfiConverterString.lift(reason)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceVideoRoomHandleCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface VideoRoomHandleCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitVideoRoomHandleCallback() {
    uniffi_janus_gateway_fn_init_callback_vtable_videoroomhandlecallback(UniffiCallbackInterfaceVideoRoomHandleCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceVideoRoomHandleCallback {
    fileprivate static let handleMap = UniffiHandleMap<VideoRoomHandleCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceVideoRoomHandleCallback : FfiConverter {
    typealias SwiftType = VideoRoomHandleCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceVideoRoomHandleCallback_lift(_ handle: UInt64) throws -> VideoRoomHandleCallback {
    return try FfiConverterCallbackInterfaceVideoRoomHandleCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceVideoRoomHandleCallback_lower(_ v: VideoRoomHandleCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceVideoRoomHandleCallback.lower(v)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAudioBridgeRTP: FfiConverterRustBuffer {
    typealias SwiftType = AudioBridgeRtp?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAudioBridgeRTP.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAudioBridgeRTP.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeJsep: FfiConverterRustBuffer {
    typealias SwiftType = Jsep?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJsep.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJsep.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLegacyVideoRoomAudioCodecList: FfiConverterRustBuffer {
    typealias SwiftType = LegacyVideoRoomAudioCodecList?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLegacyVideoRoomAudioCodecList.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLegacyVideoRoomAudioCodecList.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLegacyVideoRoomVideoCodecList: FfiConverterRustBuffer {
    typealias SwiftType = LegacyVideoRoomVideoCodecList?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLegacyVideoRoomVideoCodecList.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLegacyVideoRoomVideoCodecList.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeVideoRoomAudioCodecList: FfiConverterRustBuffer {
    typealias SwiftType = VideoRoomAudioCodecList?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVideoRoomAudioCodecList.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVideoRoomAudioCodecList.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeVideoRoomVideoCodecList: FfiConverterRustBuffer {
    typealias SwiftType = VideoRoomVideoCodecList?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVideoRoomVideoCodecList.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVideoRoomVideoCodecList.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAudioBridgeCodec: FfiConverterRustBuffer {
    typealias SwiftType = AudioBridgeCodec?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAudioBridgeCodec.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAudioBridgeCodec.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeJanusId: FfiConverterRustBuffer {
    typealias SwiftType = JanusId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJanusId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJanusId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLegacyVideoRoomVideoCodec: FfiConverterRustBuffer {
    typealias SwiftType = LegacyVideoRoomVideoCodec?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLegacyVideoRoomVideoCodec.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLegacyVideoRoomVideoCodec.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeVideoRoomVideoCodec: FfiConverterRustBuffer {
    typealias SwiftType = VideoRoomVideoCodec?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVideoRoomVideoCodec.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVideoRoomVideoCodec.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeConfiguredStream: FfiConverterRustBuffer {
    typealias SwiftType = [ConfiguredStream]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeConfiguredStream.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeConfiguredStream.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeVideoRoomConfigurePublisherStream: FfiConverterRustBuffer {
    typealias SwiftType = [VideoRoomConfigurePublisherStream]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeVideoRoomConfigurePublisherStream.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeVideoRoomConfigurePublisherStream.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeVideoRoomPublishDescriptionParams: FfiConverterRustBuffer {
    typealias SwiftType = [VideoRoomPublishDescriptionParams]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeVideoRoomPublishDescriptionParams.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeVideoRoomPublishDescriptionParams.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAudioBridgeParticipant: FfiConverterRustBuffer {
    typealias SwiftType = [AudioBridgeParticipant]

    public static func write(_ value: [AudioBridgeParticipant], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAudioBridgeParticipant.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AudioBridgeParticipant] {
        let len: Int32 = try readInt(&buf)
        var seq = [AudioBridgeParticipant]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAudioBridgeParticipant.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCandidate: FfiConverterRustBuffer {
    typealias SwiftType = [Candidate]

    public static func write(_ value: [Candidate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCandidate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Candidate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Candidate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCandidate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeConfiguredStream: FfiConverterRustBuffer {
    typealias SwiftType = [ConfiguredStream]

    public static func write(_ value: [ConfiguredStream], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeConfiguredStream.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ConfiguredStream] {
        let len: Int32 = try readInt(&buf)
        var seq = [ConfiguredStream]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeConfiguredStream.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLegacyVideoRoomPublisher: FfiConverterRustBuffer {
    typealias SwiftType = [LegacyVideoRoomPublisher]

    public static func write(_ value: [LegacyVideoRoomPublisher], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLegacyVideoRoomPublisher.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LegacyVideoRoomPublisher] {
        let len: Int32 = try readInt(&buf)
        var seq = [LegacyVideoRoomPublisher]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLegacyVideoRoomPublisher.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePublisher: FfiConverterRustBuffer {
    typealias SwiftType = [Publisher]

    public static func write(_ value: [Publisher], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublisher.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Publisher] {
        let len: Int32 = try readInt(&buf)
        var seq = [Publisher]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublisher.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeVideoRoomConfigurePublisherStream: FfiConverterRustBuffer {
    typealias SwiftType = [VideoRoomConfigurePublisherStream]

    public static func write(_ value: [VideoRoomConfigurePublisherStream], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVideoRoomConfigurePublisherStream.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VideoRoomConfigurePublisherStream] {
        let len: Int32 = try readInt(&buf)
        var seq = [VideoRoomConfigurePublisherStream]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVideoRoomConfigurePublisherStream.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeVideoRoomPublishDescriptionParams: FfiConverterRustBuffer {
    typealias SwiftType = [VideoRoomPublishDescriptionParams]

    public static func write(_ value: [VideoRoomPublishDescriptionParams], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVideoRoomPublishDescriptionParams.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VideoRoomPublishDescriptionParams] {
        let len: Int32 = try readInt(&buf)
        var seq = [VideoRoomPublishDescriptionParams]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVideoRoomPublishDescriptionParams.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLegacyVideoRoomAudioCodec: FfiConverterRustBuffer {
    typealias SwiftType = [LegacyVideoRoomAudioCodec]

    public static func write(_ value: [LegacyVideoRoomAudioCodec], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLegacyVideoRoomAudioCodec.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LegacyVideoRoomAudioCodec] {
        let len: Int32 = try readInt(&buf)
        var seq = [LegacyVideoRoomAudioCodec]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLegacyVideoRoomAudioCodec.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLegacyVideoRoomVideoCodec: FfiConverterRustBuffer {
    typealias SwiftType = [LegacyVideoRoomVideoCodec]

    public static func write(_ value: [LegacyVideoRoomVideoCodec], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLegacyVideoRoomVideoCodec.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LegacyVideoRoomVideoCodec] {
        let len: Int32 = try readInt(&buf)
        var seq = [LegacyVideoRoomVideoCodec]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLegacyVideoRoomVideoCodec.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeVideoRoomAudioCodec: FfiConverterRustBuffer {
    typealias SwiftType = [VideoRoomAudioCodec]

    public static func write(_ value: [VideoRoomAudioCodec], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVideoRoomAudioCodec.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VideoRoomAudioCodec] {
        let len: Int32 = try readInt(&buf)
        var seq = [VideoRoomAudioCodec]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVideoRoomAudioCodec.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeVideoRoomVideoCodec: FfiConverterRustBuffer {
    typealias SwiftType = [VideoRoomVideoCodec]

    public static func write(_ value: [VideoRoomVideoCodec], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVideoRoomVideoCodec.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VideoRoomVideoCodec] {
        let len: Int32 = try readInt(&buf)
        var seq = [VideoRoomVideoCodec]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVideoRoomVideoCodec.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeMetaData: FfiConverterRustBuffer {
    public static func write(_ value: [String: MetaData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeMetaData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MetaData] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MetaData]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeMetaData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureJanusGatewayInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
public func initJanusLogger(subsystem: String, category: String)  {try! rustCall() {
    uniffi_janus_gateway_fn_func_init_janus_logger(
        FfiConverterString.lower(subsystem),
        FfiConverterString.lower(category),$0
    )
}
}
public func janusConnect(config: Config)async throws  -> Connection  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_func_janus_connect(FfiConverterTypeConfig_lower(config)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeConnection_lift,
            errorHandler: FfiConverterTypeJanusGatewayConnectionError_lift
        )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_janus_gateway_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_janus_gateway_checksum_func_init_janus_logger() != 56827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_func_janus_connect() != 27438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_complete_trickle() != 64327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_configure() != 39928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_create_room() != 56852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_detach() != 13604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_exist() != 55415) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_fire_and_forget() != 33585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_fire_and_forget_with_jsep() != 6039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_hangup() != 62093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_join_room() != 62884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_list_participants() != 7752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_mute() != 55698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_send_waiton_ack() != 34307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_send_waiton_ack_with_jsep() != 25960) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_send_waiton_result() != 47125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_start_event_loop() != 16772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_trickle_candidates() != 5622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_trickle_single_candidate() != 56691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_unmute() != 10529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_connection_create_session() != 38721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_connection_server_info() != 18308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_complete_trickle() != 25982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_detach() != 10964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_fire_and_forget() != 6820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_fire_and_forget_with_jsep() != 31372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_hangup() != 48274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_send_waiton_ack() != 9815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_send_waiton_ack_with_jsep() != 40255) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_send_waiton_result() != 15964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_start() != 6138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_start_event_loop() != 42772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_start_with_jsep() != 58592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_trickle_candidates() != 101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_trickle_single_candidate() != 3746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_complete_trickle() != 24960) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_detach() != 49762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_fire_and_forget() != 43989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_fire_and_forget_with_jsep() != 28005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_hangup() != 2958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_send_waiton_ack() != 21432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_send_waiton_ack_with_jsep() != 24357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_send_waiton_result() != 24292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_start_event_loop() != 781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_trickle_candidates() != 17041) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_trickle_single_candidate() != 48289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_complete_trickle() != 53978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_create_room() != 35272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_detach() != 7403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_exist() != 53200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_fire_and_forget() != 43483) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_fire_and_forget_with_jsep() != 46681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_hangup() != 43624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_kick() != 30177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_publisher_configure() != 56682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_publisher_join() != 10072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_publisher_join_and_configure() != 61577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_send_waiton_ack() != 40893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_send_waiton_ack_with_jsep() != 64898) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_send_waiton_result() != 60224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_start() != 38038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_start_event_loop() != 2051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_subscriber_configure() != 52781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_subscriber_join() != 51090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_trickle_candidates() != 23169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandle_trickle_single_candidate() != 64622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_session_attach() != 16557) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_session_attach_audio_bridge() != 17158) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_session_attach_echo_test() != 28942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_session_attach_legacy_video_room() != 63300) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_session_attach_video_room() != 2521) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_session_destory() != 62073) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_complete_trickle() != 33029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_create_room() != 14249) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_detach() != 19085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_exist() != 35301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_fire_and_forget() != 22601) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_fire_and_forget_with_jsep() != 54355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_hangup() != 22972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_publisher_join_and_configure() != 39661) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_send_waiton_ack() != 5152) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_send_waiton_ack_with_jsep() != 47447) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_send_waiton_result() != 26883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_start_event_loop() != 36856) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_trickle_candidates() != 32955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandle_trickle_single_candidate() != 42668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_result() != 50231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_result_with_jsep() != 23251) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_room_joined_with_jsep() != 60229) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_room_joined() != 39663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_participants_joined() != 41973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_participants_updated() != 13991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_participant_left() != 5069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_handle_event() != 6243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_audio_bridge_error() != 45190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_other() != 2276) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandlecallback_on_result() != 12927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandlecallback_on_result_with_jsep() != 57945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandlecallback_on_echo_test_error() != 12056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandlecallback_on_handle_event() != 49029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandlecallback_on_other() != 50197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handlecallback_on_plugin_event() != 21699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handlecallback_on_handle_event() != 1626) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_other() != 27677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_handle_event() != 17605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_error() != 11633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_joined() != 45081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_configured() != 3953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_new_publishers() != 55055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_subscriber_attached() != 27716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_slow_link() != 29634) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_unpublished() != 45917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_subscriber_started() != 3683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_leaving() != 40337) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_legacyvideoroomhandlecallback_on_legacy_video_room_kicked() != 2902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandlecallback_on_handle_event() != 12084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandlecallback_on_video_room_error() != 25079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandlecallback_on_other() != 28224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandlecallback_on_configure_with_jsep() != 32059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandlecallback_on_room_joined() != 7821) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandlecallback_on_room_joined_with_jsep() != 63756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandlecallback_on_kicked() != 15552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_videoroomhandlecallback_on_leaving() != 46877) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAudioBridgeHandleCallback()
    uniffiCallbackInitEchotestHandleCallback()
    uniffiCallbackInitHandleCallback()
    uniffiCallbackInitLegacyVideoRoomHandleCallback()
    uniffiCallbackInitVideoRoomHandleCallback()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureJanusGatewayInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all